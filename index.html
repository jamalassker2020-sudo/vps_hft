<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>HFT ULTRA FX 2026 - Telegram + MT5 Bridge</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0e14;--card:#121820;--border:#1a2030;--txt:#c8d0dc;--dim:#5a6270;--g:#0f6;--r:#f44;--b:#0af;--y:#fc0;--gold:#ffd700}
html.light{--bg:#f4f6f8;--card:#fff;--border:#dde;--txt:#1a1a2e;--dim:#888}
body{background:var(--bg);color:var(--txt);font:11px/1.4 monospace;padding:8px;min-height:100vh}
.g{color:var(--g)}.r{color:var(--r)}.b{color:var(--b)}.y{color:var(--y)}.dim{color:var(--dim)}.gold{color:var(--gold)}
.card{background:var(--card);border:1px solid var(--border);border-radius:4px;padding:8px;margin-bottom:8px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.col{flex:1;min-width:120px}
.grid{display:grid;gap:4px}
.g2{grid-template-columns:repeat(2,1fr)}.g3{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(4,1fr)}.g6{grid-template-columns:repeat(6,1fr)}
.stat{background:var(--bg);padding:6px;border-radius:3px;text-align:center}
.stat small{display:block;font-size:9px;color:var(--dim);margin-bottom:2px}
.stat b{font-size:13px}
h1{font-size:14px;margin-bottom:4px}
table{width:100%;border-collapse:collapse;font-size:10px}
th,td{padding:4px;text-align:right}
th{color:var(--dim);font-weight:400;border-bottom:1px solid var(--border)}
td:first-child,th:first-child{text-align:left}
tr:hover{background:rgba(255,255,255,.02)}
.scroll{max-height:200px;overflow-y:auto}
.bar{height:40px;display:flex;align-items:end;gap:1px}
.bar div{flex:1;min-width:2px;border-radius:1px 1px 0 0}
.log{font-size:9px;padding:2px 4px;margin:1px 0;border-radius:2px;background:var(--bg)}
button{background:var(--card);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;cursor:pointer;font:inherit}
button:hover{background:var(--border)}
.pulse{animation:p 1.5s infinite}@keyframes p{50%{opacity:.5}}
.badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px}
.badge.on{background:#0f62;color:var(--g)}.badge.off{background:#f442;color:var(--r)}.badge.warn{background:#fc02;color:var(--y)}.badge.gold{background:#ffd7002a;color:var(--gold)}
input[type="text"]{background:var(--bg);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;font:inherit;width:100%;font-size:16px}
input[type="text"]:focus{outline:none;border-color:var(--b)}
.webhook-status{font-size:9px;margin-top:4px}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:450px;width:90%;max-height:90vh;overflow-y:auto}
.modal h3{margin-bottom:12px;font-size:14px}
.modal-buttons{display:flex;gap:8px;justify-content:flex-end;margin-top:16px;flex-wrap:wrap}
.profit-bar{height:6px;background:var(--border);border-radius:3px;overflow:hidden;margin-top:4px}
.profit-bar-fill{height:100%;transition:width 0.3s;border-radius:3px}
.lock-flash{animation:lockFlash 0.5s ease-out}
@keyframes lockFlash{0%{background:var(--gold);transform:scale(1.05)}100%{background:var(--bg);transform:scale(1)}}
.tab-btn{padding:6px 12px;border:none;background:var(--bg);color:var(--dim);cursor:pointer;border-radius:4px 4px 0 0}
.tab-btn.active{background:var(--card);color:var(--txt);border:1px solid var(--border);border-bottom:none}
.tab-content{display:none}.tab-content.active{display:block}
@media(max-width:600px){.g6{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>
<div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
<div>
<h1>‚ö° HFT ULTRA <span class="y">FX</span> <span class="gold">SMART LOCK</span> <span class="dim">2026</span></h1>
<small class="dim">28 PAIRS ‚Ä¢ TELEGRAM + MT5 BRIDGE ‚Ä¢ ACCUMULATING PROFIT LOCK ‚Ä¢ ECB SIGNALS</small>
</div>
<div class="row" style="gap:4px">
<span id="status" class="badge pulse">INIT</span>
<span id="mode" class="badge">MODE:--</span>
<span id="api" class="badge dim">API:--</span>
<span id="telegramStatus" class="badge dim">TG:--</span>
<span id="mt5Status" class="badge dim">MT5:--</span>
<span id="shield" class="badge">SHIELD:--</span>
<button onclick="showConfig()">‚öôÔ∏è</button>
<button onclick="reset()">‚ü≤</button>
</div>
</div>

<div class="grid g6" style="margin-bottom:8px">
<div class="stat"><small>üí∞ EQUITY</small><b id="equity" class="g">$100.00</b><div id="pnlPct" style="font-size:9px">+0.00%</div></div>
<div class="stat" id="lockedStat"><small>üîí LOCKED (‚àû)</small><b id="locked" class="gold">$0.00</b><div id="lockPct" style="font-size:9px;color:var(--gold)">0 locks</div></div>
<div class="stat"><small>TRADES</small><b id="trades" class="b">0</b></div>
<div class="stat"><small>WIN%</small><b id="winrate" class="y">0%</b></div>
<div class="stat"><small>PROFIT F.</small><b id="pf" class="g">0.00</b></div>
<div class="stat"><small>OPEN</small><b id="openPos" class="b">0/6</b></div>
<div class="stat"><small>STREAK</small><b id="streak">0</b></div>
<div class="stat"><small>PEAK</small><b id="best" class="g">$100</b></div>
<div class="stat"><small>DD</small><b id="dd" class="r">0%</b></div>
<div class="stat"><small>TODAY</small><b id="todayPnl" class="g">$0</b></div>
<div class="stat"><small>TG SIGNALS</small><b id="signalsSent" class="b">0</b></div>
<div class="stat"><small>SHARPE</small><b id="sharpe" class="b">0.00</b></div>
</div>

<!-- Profit Protection Status -->
<div class="card" style="padding:6px">
<div class="row" style="justify-content:space-between;align-items:center">
<div style="flex:1">
<small class="dim">üéØ DAILY TARGET</small>
<div class="profit-bar"><div id="targetBar" class="profit-bar-fill" style="width:0%;background:var(--g)"></div></div>
</div>
<div style="flex:1;margin-left:12px">
<small class="dim">üîí NEXT LOCK @<span id="nextLockAt">$102</span></small>
<div class="profit-bar"><div id="lockBar" class="profit-bar-fill" style="width:0%;background:var(--gold)"></div></div>
</div>
<div style="flex:1;margin-left:12px">
<small class="dim">üî• RISK HEAT</small>
<div class="profit-bar"><div id="heatBar" class="profit-bar-fill" style="width:0%;background:var(--r)"></div></div>
</div>
</div>
</div>

<div class="row">
<div class="col" style="flex:3">
<div class="card">
<div class="row" style="justify-content:space-between;margin-bottom:4px">
<b class="b">üìä FOREX MARKET</b>
<span id="time" class="dim">--:--:--</span>
</div>
<div class="scroll"><table><thead><tr><th>PAIR</th><th>BID</th><th>ASK</th><th>SPR</th><th>RSI</th><th>MOM</th><th>ECB</th><th>SIG</th><th>P&L</th></tr></thead><tbody id="market"></tbody></table></div>
</div>
</div>
<div class="col">
<div class="card">
<b>üìà POSITIONS</b>
<div id="positions" class="scroll" style="margin-top:4px"><span class="dim">Scanning...</span></div>
</div>
<div class="card">
<b>‚ö° LOG</b>
<div id="log" class="scroll" style="margin-top:4px"><span class="dim">Starting...</span></div>
</div>
</div>
</div>

<div class="row">
<div class="col">
<div class="card"><b>üíπ EQUITY</b><div class="bar" id="chart"></div></div>
</div>
<div class="col">
<div class="card">
<b>üõ°Ô∏è ACCUMULATING PROFIT LOCK + BRIDGE</b>
<div class="grid g3" style="margin-top:6px;font-size:9px;text-align:center">
<div class="stat"><small>LOCK STEP</small><span id="lockStep" class="gold">$2</span></div>
<div class="stat"><small>LOCK %</small><span id="lockPctStat" class="gold">50%</span></div>
<div class="stat"><small>LOCK COUNT</small><span id="lockCount" class="gold">0</span></div>
<div class="stat"><small>TG BOT</small><span id="botStatus" class="y">--</span></div>
<div class="stat"><small>MT5 LINK</small><span id="mt5LinkStatus" class="y">--</span></div>
<div class="stat"><small>LOT</small><span id="lotSize" class="b">0.01</span></div>
</div>
</div>
</div>
</div>

<!-- Configuration Modal -->
<div id="configModal" class="modal-overlay" style="display:none">
<div class="modal">
<h3>‚öôÔ∏è TELEGRAM + MT5 CONFIGURATION</h3>

<div style="margin-bottom:12px">
<button class="tab-btn active" onclick="switchTab('telegram')">üì± Telegram</button>
<button class="tab-btn" onclick="switchTab('mt5')">üîó MT5 Webhook</button>
<button class="tab-btn" onclick="switchTab('trading')">üìä Trading</button>
</div>

<!-- Telegram Tab -->
<div id="tab-telegram" class="tab-content active">
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">Bot Token (from @BotFather)</label>
<input type="text" id="telegramToken" placeholder="1234567890:ABCdefGHI..." value="8488789199:AAHhViKmhXlve7WpgZGvDS4wjCju">
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">Chat ID (from @userinfobot)</label>
<input type="text" id="telegramChatId" placeholder="123456789" value="93372553">
</div>
<div class="grid g2" style="margin-bottom:12px">
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgSignalEnabled" checked> Send Signals
</label>
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgAlertEnabled" checked> Send Alerts
</label>
</div>
<button onclick="testTelegram()" style="width:100%">üß™ Test Telegram Connection</button>
</div>

<!-- MT5 Tab -->
<div id="tab-mt5" class="tab-content">
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">MT5 EA Webhook URL</label>
<input type="text" id="mt5WebhookUrl" placeholder="http://localhost:5000/webhook" value="https://docker-metatrader-production.up.railway.app/">
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">Secret Key (optional)</label>
<input type="text" id="mt5Secret" placeholder="your-secret-key">
</div>
<div class="grid g2" style="margin-bottom:12px">
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="mt5OpenEnabled" checked> Send on OPEN
</label>
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="mt5CloseEnabled" checked> Send on CLOSE
</label>
</div>
<button onclick="testMT5()" style="width:100%">üîó Test MT5 Connection</button>
</div>

<!-- Trading Tab -->
<div id="tab-trading" class="tab-content">
<div class="grid g2" style="margin-bottom:12px">
<div>
<label class="dim" style="display:block;margin-bottom:4px">Take Profit (pips)</label>
<input type="text" id="cfgTP" value="15">
</div>
<div>
<label class="dim" style="display:block;margin-bottom:4px">Stop Loss (pips)</label>
<input type="text" id="cfgSL" value="5">
</div>
</div>
<div class="grid g2" style="margin-bottom:12px">
<div>
<label class="dim" style="display:block;margin-bottom:4px">Lock Step ($)</label>
<input type="text" id="cfgLockStep" value="2">
</div>
<div>
<label class="dim" style="display:block;margin-bottom:4px">Lock % of Step</label>
<input type="text" id="cfgLockPct" value="50">
</div>
</div>
<div class="grid g2" style="margin-bottom:12px">
<div>
<label class="dim" style="display:block;margin-bottom:4px">Base Lot Size</label>
<input type="text" id="cfgLot" value="0.01">
</div>
<div>
<label class="dim" style="display:block;margin-bottom:4px">Max Positions</label>
<input type="text" id="cfgMaxPos" value="6">
</div>
</div>
</div>

<div class="webhook-status" id="testResult"></div>
<div class="modal-buttons">
<button onclick="saveConfig()">üíæ Save All</button>
<button onclick="closeConfig()">‚úï Close</button>
</div>
</div>
</div>

<script>
// Dark/Light mode
if(matchMedia('(prefers-color-scheme:light)').matches)document.documentElement.classList.add('light');
matchMedia('(prefers-color-scheme:light)').onchange=e=>document.documentElement.classList.toggle('light',e.matches);

// =====================================================
// FOREX INSTRUMENTS (28 pairs)
// =====================================================
const SYM=[
  {s:'EUR/USD',base:'EUR',quote:'USD',p:0.0001,t:'major',mt5:'EURUSD',spread:1.2},
  {s:'GBP/USD',base:'GBP',quote:'USD',p:0.0001,t:'major',mt5:'GBPUSD',spread:1.5},
  {s:'USD/JPY',base:'USD',quote:'JPY',p:0.01,t:'major',mt5:'USDJPY',spread:1.3},
  {s:'USD/CHF',base:'USD',quote:'CHF',p:0.0001,t:'major',mt5:'USDCHF',spread:1.8},
  {s:'AUD/USD',base:'AUD',quote:'USD',p:0.0001,t:'major',mt5:'AUDUSD',spread:1.4},
  {s:'USD/CAD',base:'USD',quote:'CAD',p:0.0001,t:'major',mt5:'USDCAD',spread:1.6},
  {s:'NZD/USD',base:'NZD',quote:'USD',p:0.0001,t:'major',mt5:'NZDUSD',spread:1.8},
  {s:'EUR/GBP',base:'EUR',quote:'GBP',p:0.0001,t:'cross',mt5:'EURGBP',spread:1.5},
  {s:'EUR/JPY',base:'EUR',quote:'JPY',p:0.01,t:'cross',mt5:'EURJPY',spread:1.8},
  {s:'EUR/CHF',base:'EUR',quote:'CHF',p:0.0001,t:'cross',mt5:'EURCHF',spread:2.0},
  {s:'EUR/AUD',base:'EUR',quote:'AUD',p:0.0001,t:'cross',mt5:'EURAUD',spread:2.5},
  {s:'EUR/CAD',base:'EUR',quote:'CAD',p:0.0001,t:'cross',mt5:'EURCAD',spread:2.2},
  {s:'EUR/NZD',base:'EUR',quote:'NZD',p:0.0001,t:'cross',mt5:'EURNZD',spread:3.0},
  {s:'GBP/JPY',base:'GBP',quote:'JPY',p:0.01,t:'cross',mt5:'GBPJPY',spread:2.5},
  {s:'GBP/CHF',base:'GBP',quote:'CHF',p:0.0001,t:'cross',mt5:'GBPCHF',spread:2.8},
  {s:'GBP/AUD',base:'GBP',quote:'AUD',p:0.0001,t:'cross',mt5:'GBPAUD',spread:3.0},
  {s:'GBP/CAD',base:'GBP',quote:'CAD',p:0.0001,t:'cross',mt5:'GBPCAD',spread:2.8},
  {s:'GBP/NZD',base:'GBP',quote:'NZD',p:0.0001,t:'cross',mt5:'GBPNZD',spread:3.5},
  {s:'AUD/JPY',base:'AUD',quote:'JPY',p:0.01,t:'cross',mt5:'AUDJPY',spread:2.0},
  {s:'AUD/NZD',base:'AUD',quote:'NZD',p:0.0001,t:'cross',mt5:'AUDNZD',spread:2.5},
  {s:'AUD/CAD',base:'AUD',quote:'CAD',p:0.0001,t:'cross',mt5:'AUDCAD',spread:2.2},
  {s:'AUD/CHF',base:'AUD',quote:'CHF',p:0.0001,t:'cross',mt5:'AUDCHF',spread:2.5},
  {s:'NZD/JPY',base:'NZD',quote:'JPY',p:0.01,t:'cross',mt5:'NZDJPY',spread:2.5},
  {s:'NZD/CAD',base:'NZD',quote:'CAD',p:0.0001,t:'cross',mt5:'NZDCAD',spread:2.8},
  {s:'NZD/CHF',base:'NZD',quote:'CHF',p:0.0001,t:'cross',mt5:'NZDCHF',spread:3.0},
  {s:'CAD/JPY',base:'CAD',quote:'JPY',p:0.01,t:'cross',mt5:'CADJPY',spread:2.2},
  {s:'CAD/CHF',base:'CAD',quote:'CHF',p:0.0001,t:'cross',mt5:'CADCHF',spread:2.5},
  {s:'XAU/USD',base:'XAU',quote:'USD',p:0.01,t:'metal',mt5:'XAUUSD',spread:25}
];

// ECB Interest Rates and Central Bank Bias
const ECB_BIAS = {
  'EUR': {rate: 4.0, bias: 'hawkish'},
  'USD': {rate: 5.5, bias: 'hawkish'},
  'GBP': {rate: 5.25, bias: 'hawkish'},
  'JPY': {rate: -0.1, bias: 'dovish'},
  'CHF': {rate: 1.75, bias: 'neutral'},
  'CAD': {rate: 5.0, bias: 'neutral'},
  'AUD': {rate: 4.35, bias: 'neutral'},
  'NZD': {rate: 5.5, bias: 'hawkish'},
  'XAU': {rate: 0, bias: 'neutral'}
};

// =====================================================
// CONFIGURATION
// =====================================================
let C = {
  start: 100,
  baseLot: 0.01,
  tp: 15,
  sl: 5,
  breakEvenTrigger: 3,
  breakEvenPlus: 0.5,
  trail1Trigger: 5,
  trail1Distance: 2,
  trail2Trigger: 8,
  trail2Distance: 1.5,
  trail3Trigger: 12,
  trail3Distance: 1,
  partial1Trigger: 6,
  partial1Pct: 0.5,
  profitLockStep: 2,
  profitLockPct: 50,
  dailyTarget: 3,
  dailyLossLimit: 2,
  maxHoldTime: 300000,
  stagnantThreshold: 2,
  momentumExitThreshold: 0.03,
  rsiExitBuffer: 10,
  maxPos: 6,
  maxDD: 5,
  cooldown: 5000,
  rsiPeriod: 14,
  minRSI: 25,
  maxRSI: 75,
  minStrength: 3,
  spreadMax: 3
};

// =====================================================
// TELEGRAM + MT5 CONFIGURATION
// =====================================================
let bridgeConfig = {
  // Telegram
  telegramToken: '8488789199:AAHhViKmhXlve7WpgZGvDS4wjCju',
  telegramChatId: '93372553',
  signalEnabled: true,
  alertEnabled: true,
  // MT5
  mt5Url: 'https://docker-metatrader-production.up.railway.app/',
  mt5Secret: '',
  mt5OpenEnabled: true,
  mt5CloseEnabled: true,
  // Stats
  signalsSent: 0,
  signalsToday: 0,
  lastSignalTime: null,
  successCount: 0,
  errorCount: 0
};

// =====================================================
// STATE
// =====================================================
let S = load() || fresh();
let prices = {}, priceHistory = {}, lastTrade = {}, logs = [], ticks = 0, dailyPnL = 0, dayStart = new Date().toDateString();
let ecbRates = {};
let tradingMode = 'NORMAL';

function fresh() {
  return {
    bal: C.start,
    pos: [],
    wins: 0,
    losses: 0,
    grossWin: 0,
    grossLoss: 0,
    eq: [C.start],
    streak: 0,
    best: C.start,
    peak: C.start,
    returns: [],
    lockedProfit: 0,
    lockCount: 0,
    lastLockLevel: C.start,
    sessionPeak: C.start,
    dailyStartBal: C.start
  };
}

function load() {
  try {
    const hash = location.hash.slice(1);
    if (hash) {
      const data = JSON.parse(atob(hash));
      if (data.bridgeConfig) {
        bridgeConfig = { ...bridgeConfig, ...data.bridgeConfig };
      }
      data.lockedProfit = data.lockedProfit || 0;
      data.lockCount = data.lockCount || 0;
      data.lastLockLevel = data.lastLockLevel || C.start;
      data.sessionPeak = data.sessionPeak || data.peak || C.start;
      data.dailyStartBal = data.dailyStartBal || C.start;
      return data;
    }
  } catch (e) {
    console.log('No saved data found');
  }
  return null;
}

function save() {
  try {
    const data = {
      ...S,
      eq: S.eq.slice(-60),
      returns: S.returns.slice(-100),
      bridgeConfig: bridgeConfig
    };
    history.replaceState(null, '', '#' + btoa(JSON.stringify(data)));
  } catch (e) {}
}

function reset() {
  S = fresh();
  logs = [];
  prices = {};
  priceHistory = {};
  dailyPnL = 0;
  ecbRates = {};
  tradingMode = 'NORMAL';
  bridgeConfig.signalsToday = 0;
  save();
  render();
  log('üîÑ System reset', 'b');
}

// =====================================================
// CONFIG MODAL
// =====================================================
function switchTab(tab) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
  event.target.classList.add('active');
  document.getElementById('tab-' + tab).classList.add('active');
}

function showConfig() {
  document.getElementById('telegramToken').value = bridgeConfig.telegramToken;
  document.getElementById('telegramChatId').value = bridgeConfig.telegramChatId;
  document.getElementById('tgSignalEnabled').checked = bridgeConfig.signalEnabled;
  document.getElementById('tgAlertEnabled').checked = bridgeConfig.alertEnabled;
  document.getElementById('mt5WebhookUrl').value = bridgeConfig.mt5Url;
  document.getElementById('mt5Secret').value = bridgeConfig.mt5Secret;
  document.getElementById('mt5OpenEnabled').checked = bridgeConfig.mt5OpenEnabled;
  document.getElementById('mt5CloseEnabled').checked = bridgeConfig.mt5CloseEnabled;
  document.getElementById('cfgTP').value = C.tp;
  document.getElementById('cfgSL').value = C.sl;
  document.getElementById('cfgLockStep').value = C.profitLockStep;
  document.getElementById('cfgLockPct').value = C.profitLockPct;
  document.getElementById('cfgLot').value = C.baseLot;
  document.getElementById('cfgMaxPos').value = C.maxPos;
  document.getElementById('configModal').style.display = 'flex';
}

function closeConfig() {
  document.getElementById('configModal').style.display = 'none';
}

function saveConfig() {
  bridgeConfig.telegramToken = document.getElementById('telegramToken').value.trim();
  bridgeConfig.telegramChatId = document.getElementById('telegramChatId').value.trim();
  bridgeConfig.signalEnabled = document.getElementById('tgSignalEnabled').checked;
  bridgeConfig.alertEnabled = document.getElementById('tgAlertEnabled').checked;
  bridgeConfig.mt5Url = document.getElementById('mt5WebhookUrl').value.trim();
  bridgeConfig.mt5Secret = document.getElementById('mt5Secret').value.trim();
  bridgeConfig.mt5OpenEnabled = document.getElementById('mt5OpenEnabled').checked;
  bridgeConfig.mt5CloseEnabled = document.getElementById('mt5CloseEnabled').checked;
  
  C.tp = parseInt(document.getElementById('cfgTP').value) || 15;
  C.sl = parseInt(document.getElementById('cfgSL').value) || 5;
  C.profitLockStep = parseFloat(document.getElementById('cfgLockStep').value) || 2;
  C.profitLockPct = parseFloat(document.getElementById('cfgLockPct').value) || 50;
  C.baseLot = parseFloat(document.getElementById('cfgLot').value) || 0.01;
  C.maxPos = parseInt(document.getElementById('cfgMaxPos').value) || 6;
  
  save();
  updateBridgeUI();
  closeConfig();
  log('üíæ Configuration saved', 'g');
}

async function testTelegram() {
  const token = document.getElementById('telegramToken').value.trim();
  const chatId = document.getElementById('telegramChatId').value.trim();
  const resultEl = document.getElementById('testResult');
  
  if (!token || !chatId) {
    resultEl.innerHTML = '<span class="r">‚ùå Enter Token & Chat ID</span>';
    return;
  }
  
  resultEl.innerHTML = '<span class="y">üîÑ Testing Telegram...</span>';
  
  try {
    const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
    const data = await response.json();
    
    if (data.ok) {
      resultEl.innerHTML = `<span class="g">‚úÖ Bot connected: @${data.result.username}</span>`;
      
      // Send test message
      await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          chat_id: chatId,
          text: '‚úÖ HFT ULTRA FX 2026 Connected!\nüîó Telegram Bridge Active\nüí∞ Accumulating Profit Lock: ON\nüìä Ready for trading signals!',
          parse_mode: 'HTML'
        })
      });
      log('‚úÖ Telegram test successful', 'g');
    } else {
      resultEl.innerHTML = '<span class="r">‚ùå Invalid bot token</span>';
    }
  } catch (err) {
    resultEl.innerHTML = `<span class="r">‚ùå Error: ${err.message}</span>`;
  }
}

async function testMT5() {
  const url = document.getElementById('mt5WebhookUrl').value.trim();
  const resultEl = document.getElementById('testResult');
  
  if (!url) {
    resultEl.innerHTML = '<span class="r">‚ùå Enter MT5 Webhook URL</span>';
    return;
  }
  
  resultEl.innerHTML = '<span class="y">üîÑ Testing MT5...</span>';
  
  const testSignal = {
    action: 'TEST',
    symbol: 'EURUSD',
    type: 'BUY',
    price: 1.0850,
    lot: 0.01,
    sl: 1.0840,
    tp: 1.0870,
    comment: 'HFT-TEST-' + Date.now(),
    magic: 2026,
    timestamp: new Date().toISOString(),
    source: 'HFT-ULTRA-FX-2026'
  };
  
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(testSignal)
    });
    
    if (response.ok) {
      resultEl.innerHTML = '<span class="g">‚úÖ MT5 connection successful</span>';
      log('‚úÖ MT5 test successful', 'g');
    } else {
      resultEl.innerHTML = `<span class="r">‚ùå MT5 error: ${response.status}</span>`;
    }
  } catch (err) {
    resultEl.innerHTML = `<span class="r">‚ùå MT5 error: ${err.message}</span>`;
  }
}

function updateBridgeUI() {
  // Telegram status
  const tgEl = document.getElementById('telegramStatus');
  if (bridgeConfig.telegramToken && bridgeConfig.telegramChatId) {
    tgEl.textContent = 'TG:‚úì';
    tgEl.className = 'badge on';
    document.getElementById('botStatus').textContent = 'ONLINE';
    document.getElementById('botStatus').className = 'g';
  } else {
    tgEl.textContent = 'TG:OFF';
    tgEl.className = 'badge dim';
    document.getElementById('botStatus').textContent = 'OFF';
    document.getElementById('botStatus').className = 'r';
  }
  
  // MT5 status
  const mt5El = document.getElementById('mt5Status');
  if (bridgeConfig.mt5Url) {
    mt5El.textContent = 'MT5:‚úì';
    mt5El.className = 'badge on';
    document.getElementById('mt5LinkStatus').textContent = 'LINKED';
    document.getElementById('mt5LinkStatus').className = 'g';
  } else {
    mt5El.textContent = 'MT5:OFF';
    mt5El.className = 'badge dim';
    document.getElementById('mt5LinkStatus').textContent = 'OFF';
    document.getElementById('mt5LinkStatus').className = 'dim';
  }
  
  document.getElementById('signalsSent').textContent = bridgeConfig.signalsSent;
}

// =====================================================
// TELEGRAM + MT5 SIGNAL FORWARDING
// =====================================================
async function sendTelegramSignal(signalData) {
  if (!bridgeConfig.signalEnabled || !bridgeConfig.telegramToken || !bridgeConfig.telegramChatId) {
    return false;
  }
  
  let message = '';
  const sym = SYM.find(s => s.s === signalData.symbol || s.mt5 === signalData.symbol);
  const baseCurrency = sym ? sym.base : signalData.symbol.substring(0, 3);
  const quoteCurrency = sym ? sym.quote : signalData.symbol.substring(3, 6);
  const baseBias = ECB_BIAS[baseCurrency] ? ECB_BIAS[baseCurrency].bias : 'neutral';
  const quoteBias = ECB_BIAS[quoteCurrency] ? ECB_BIAS[quoteCurrency].bias : 'neutral';
  
  if (signalData.action === 'OPEN') {
    message = `üöÄ <b>${signalData.direction} ${signalData.symbol}</b>\n`;
    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    message += `üí∞ Entry: <code>${signalData.entry.toFixed(5)}</code>\n`;
    message += `üéØ TP: <code>${signalData.tp.toFixed(5)}</code> (+${C.tp}p)\n`;
    message += `üõë SL: <code>${signalData.sl.toFixed(5)}</code> (-${C.sl}p)\n`;
    message += `üìä Lot: <code>${signalData.lot}</code>\n`;
    message += `‚ö° Strength: ${signalData.strength}/5\n`;
    message += `üè¶ ECB: ${baseBias.toUpperCase()} vs ${quoteBias.toUpperCase()}\n`;
    message += `üîí Locked: $${S.lockedProfit.toFixed(2)} (${S.lockCount} locks)\n`;
    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    message += `üÜî <code>${signalData.id}</code>`;
  } else {
    const emoji = signalData.reason === 'TP' ? '‚úÖ' : signalData.reason === 'TRAIL' ? 'üìà' : signalData.reason === 'BE' ? 'üîí' : '‚ùå';
    message = `${emoji} <b>${signalData.symbol} CLOSED</b>\n`;
    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    message += `üìä Exit: <b>${signalData.reason}</b>\n`;
    message += `üí∞ P&L: <code>${signalData.pnl >= 0 ? '+' : ''}$${signalData.pnl.toFixed(2)}</code>\n`;
    message += `üìà Pips: <code>${signalData.pips >= 0 ? '+' : ''}${signalData.pips.toFixed(1)}</code>\n`;
    message += `‚è±Ô∏è Duration: ${Math.round(signalData.duration / 1000)}s\n`;
    message += `üíº Balance: $${S.bal.toFixed(2)}\n`;
    message += `üîí Protected: $${S.lockedProfit.toFixed(2)}\n`;
    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    message += `üÜî <code>${signalData.id}</code>`;
  }
  
  try {
    const response = await fetch(`https://api.telegram.org/bot${bridgeConfig.telegramToken}/sendMessage`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        chat_id: bridgeConfig.telegramChatId,
        text: message,
        parse_mode: 'HTML',
        disable_web_page_preview: true
      })
    });
    
    if (response.ok) {
      bridgeConfig.signalsSent++;
      bridgeConfig.signalsToday++;
      bridgeConfig.lastSignalTime = new Date().toISOString();
      bridgeConfig.successCount++;
      updateBridgeUI();
      log(`üì± TG: ${signalData.action} ${signalData.symbol}`, 'b');
      return true;
    }
  } catch (err) {
    bridgeConfig.errorCount++;
    log(`‚ö†Ô∏è TG Error: ${err.message}`, 'y');
  }
  return false;
}

async function sendMT5Signal(signalData) {
  if (!bridgeConfig.mt5Url) return false;
  if (signalData.action === 'OPEN' && !bridgeConfig.mt5OpenEnabled) return false;
  if (signalData.action === 'CLOSE' && !bridgeConfig.mt5CloseEnabled) return false;
  
  const sym = SYM.find(s => s.s === signalData.symbol);
  
  const mt5Payload = {
    action: signalData.action,
    symbol: sym ? sym.mt5 : signalData.symbol.replace('/', ''),
    type: signalData.direction,
    order_type: signalData.direction === 'BUY' ? 0 : 1,
    price: signalData.entry || signalData.exitPrice,
    lot: signalData.lot,
    sl: signalData.sl,
    tp: signalData.tp,
    comment: `HFT-${signalData.id}`,
    magic: 2026,
    timestamp: new Date().toISOString(),
    source: 'HFT-ULTRA-FX-2026',
    trade_id: signalData.id,
    exit_reason: signalData.reason || null,
    pnl_pips: signalData.pips || null,
    pnl_usd: signalData.pnl || null,
    account: {
      balance: S.bal,
      equity: S.bal + getUnrealized(),
      locked_profit: S.lockedProfit,
      lock_count: S.lockCount
    },
    auth: bridgeConfig.mt5Secret ? {
      secret: bridgeConfig.mt5Secret,
      signature: btoa(bridgeConfig.mt5Secret + ':' + Date.now())
    } : null
  };
  
  try {
    const response = await fetch(bridgeConfig.mt5Url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Signal-Source': 'HFT-ULTRA-FX-2026',
        'X-Signal-Action': signalData.action,
        ...(bridgeConfig.mt5Secret && { 'X-Auth-Key': bridgeConfig.mt5Secret })
      },
      body: JSON.stringify(mt5Payload)
    });
    
    if (response.ok) {
      log(`üîó MT5: ${signalData.action} ${signalData.symbol}`, 'g');
      return true;
    }
  } catch (err) {
    log(`‚ö†Ô∏è MT5 Error: ${err.message}`, 'y');
  }
  return false;
}

async function sendAlert(message, type = 'info') {
  if (!bridgeConfig.alertEnabled || !bridgeConfig.telegramToken || !bridgeConfig.telegramChatId) return;
  
  const emoji = type === 'info' ? '‚ÑπÔ∏è' : type === 'warning' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : 'üö®';
  
  try {
    await fetch(`https://api.telegram.org/bot${bridgeConfig.telegramToken}/sendMessage`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        chat_id: bridgeConfig.telegramChatId,
        text: `${emoji} <b>HFT ULTRA ALERT</b>\n${message}`,
        parse_mode: 'HTML'
      })
    });
  } catch (err) {
    console.log('Alert failed:', err);
  }
}

// =====================================================
// FOREX PRICE DATA
// =====================================================
async function fetchECBRates() {
  try {
    const r = await fetch('https://api.frankfurter.app/latest?from=USD');
    const data = await r.json();
    
    ecbRates = {
      'USD': 1,
      'EUR': 1 / data.rates.EUR,
      'GBP': 1 / data.rates.GBP,
      'JPY': data.rates.JPY,
      'CHF': data.rates.CHF,
      'AUD': 1 / data.rates.AUD,
      'CAD': data.rates.CAD,
      'NZD': 1 / data.rates.NZD,
    };
    
    ecbRates['XAU'] = 2650 + (Math.random() - 0.5) * 20;
    
    document.getElementById('api').textContent = 'API:ECB‚úì';
    document.getElementById('api').className = 'badge on';
    return true;
  } catch (e) {
    ecbRates = {
      'USD': 1, 'EUR': 1.0850, 'GBP': 1.2650, 'JPY': 149.50,
      'CHF': 0.8850, 'AUD': 0.6550, 'CAD': 1.3550, 'NZD': 0.6150, 'XAU': 2650
    };
    document.getElementById('api').textContent = 'API:SIM';
    document.getElementById('api').className = 'badge warn';
    return true;
  }
}

function getCrossRate(base, quote) {
  if (base === 'USD') return ecbRates[quote] || 1;
  if (quote === 'USD') return ecbRates[base] || 1;
  const baseUSD = ecbRates[base] || 1;
  const quoteUSD = ecbRates[quote] || 1;
  if (quote === 'JPY') return baseUSD * ecbRates['JPY'];
  if (base === 'JPY') return 1 / (quoteUSD * ecbRates['JPY']);
  return baseUSD / quoteUSD;
}

function simulateTick(sym, basePrice) {
  const pip = sym.p;
  const volatility = sym.t === 'metal' ? 0.5 : (sym.t === 'major' ? 0.3 : 0.4);
  return basePrice + (Math.random() - 0.5) * volatility * pip * 10;
}

function updatePrices() {
  SYM.forEach(sym => {
    let baseMid = getCrossRate(sym.base, sym.quote);
    const prevMid = prices[sym.s]?.mid || baseMid;
    const newMid = simulateTick(sym, prevMid);
    const reversion = (baseMid - newMid) * 0.01;
    const mid = newMid + reversion;
    
    if (!priceHistory[sym.s]) priceHistory[sym.s] = [];
    priceHistory[sym.s].push(mid);
    if (priceHistory[sym.s].length > 50) priceHistory[sym.s].shift();
    
    const spreadPips = sym.spread * (0.8 + Math.random() * 0.4);
    const halfSpread = (spreadPips * sym.p) / 2;
    
    prices[sym.s] = {
      bid: mid - halfSpread,
      ask: mid + halfSpread,
      mid,
      change: prices[sym.s] ? (mid - prices[sym.s].mid) / sym.p : 0,
      spread: spreadPips,
      pip: sym.p,
      type: sym.t
    };
  });
  ticks++;
}

// =====================================================
// INDICATORS
// =====================================================
function calcRSI(sym) {
  const h = priceHistory[sym];
  if (!h || h.length < C.rsiPeriod + 1) return 50;
  let gains = 0, losses = 0;
  for (let i = h.length - C.rsiPeriod; i < h.length; i++) {
    const diff = h[i] - h[i - 1];
    if (diff > 0) gains += diff;
    else losses -= diff;
  }
  if (losses === 0) return 100;
  return 100 - (100 / (1 + gains / losses));
}

function calcMomentum(sym) {
  const h = priceHistory[sym];
  if (!h || h.length < 10) return 0;
  return ((h[h.length - 1] - h[h.length - 10]) / h[h.length - 10]) * 100;
}

function calcVolatility(sym) {
  const h = priceHistory[sym];
  if (!h || h.length < 10) return 1;
  let sum = 0;
  for (let i = 1; i < Math.min(h.length, 10); i++) {
    sum += Math.abs(h[i] - h[i - 1]);
  }
  return sum / 9;
}

function getECBBias(sym) {
  const symData = SYM.find(s => s.s === sym);
  if (!symData) return 0;
  const baseBias = ECB_BIAS[symData.base]?.bias || 'neutral';
  const quoteBias = ECB_BIAS[symData.quote]?.bias || 'neutral';
  
  if (baseBias === 'hawkish' && quoteBias === 'dovish') return 1;
  if (baseBias === 'dovish' && quoteBias === 'hawkish') return -1;
  if (baseBias === 'hawkish' && quoteBias === 'neutral') return 0.5;
  if (baseBias === 'neutral' && quoteBias === 'dovish') return 0.5;
  if (baseBias === 'dovish' && quoteBias === 'neutral') return -0.5;
  if (baseBias === 'neutral' && quoteBias === 'hawkish') return -0.5;
  return 0;
}

function getCorrelatedPairs(sym) {
  const corr = {
    'EUR/USD': ['GBP/USD', 'EUR/GBP'],
    'GBP/USD': ['EUR/USD', 'EUR/GBP'],
    'USD/JPY': ['EUR/JPY', 'GBP/JPY'],
    'AUD/USD': ['NZD/USD', 'AUD/NZD'],
    'XAU/USD': ['EUR/USD']
  };
  return corr[sym] || [];
}

function getSignal(sym) {
  const p = prices[sym];
  if (!p) return { score: 0, strength: 0, sig: null, rsi: 50, mom: 0, ecbBias: 0 };
  
  const rsi = calcRSI(sym);
  const mom = calcMomentum(sym);
  const ecbBias = getECBBias(sym);
  
  let score = 0, strength = 0;
  
  // RSI
  if (rsi < C.minRSI) { score += 20; strength++; }
  else if (rsi > C.maxRSI) { score -= 20; strength++; }
  else if (rsi < 40) { score += 10; }
  else if (rsi > 60) { score -= 10; }
  
  // Momentum
  if (mom > 0.02 && rsi < 50) { score += 15; strength++; }
  else if (mom < -0.02 && rsi > 50) { score -= 15; strength++; }
  
  // ECB Bias
  if (ecbBias > 0) { score += 15; strength++; }
  else if (ecbBias < 0) { score -= 15; strength++; }
  
  // MA
  const h = priceHistory[sym];
  if (h && h.length >= 20) {
    const ma20 = h.slice(-20).reduce((a, b) => a + b, 0) / 20;
    if (p.mid > ma20 && mom > 0) { score += 12; strength++; }
    else if (p.mid < ma20 && mom < 0) { score -= 12; strength++; }
  }
  
  // Correlation
  const corr = getCorrelatedPairs(sym);
  corr.forEach(c => {
    const cp = prices[c];
    if (cp && ((score > 0 && cp.change > 0) || (score < 0 && cp.change < 0))) strength++;
  });
  
  if (p.spread > C.spreadMax) return { score, strength: 0, sig: null, rsi: Math.round(rsi), mom: mom.toFixed(3), ecbBias };
  
  const reqStrength = tradingMode === 'DEFENSIVE' ? C.minStrength + 1: C.minStrength;
  const reqScore = tradingMode === 'DEFENSIVE' ? 30 : 25;
  
  let sig = null;
  if (score >= reqScore && strength >= reqStrength) sig = 'BUY';
  else if (score <= -reqScore && strength >= reqStrength) sig = 'SELL';
  
  return { score, strength, sig, rsi: Math.round(rsi), mom: mom.toFixed(3), ecbBias };
}

// =====================================================
// ACCUMULATING PROFIT LOCK
// =====================================================
function updateProfitLock() {
  const equity = S.bal + getUnrealized();
  
  if (equity > S.sessionPeak) S.sessionPeak = equity;
  
  const lockStep = C.profitLockStep;
  
  while (equity >= S.lastLockLevel + lockStep) {
    const lockAmount = lockStep * (C.profitLockPct / 100);
    S.lockedProfit += lockAmount;
    S.lockCount++;
    S.lastLockLevel += lockStep;
    
    flashLockStat();
    log(`üîí LOCK #${S.lockCount}: +$${lockAmount.toFixed(2)} ‚Üí TOTAL: $${S.lockedProfit.toFixed(2)}`, 'gold');
    
    // Send Telegram alert for profit lock
    sendAlert(`üîí PROFIT LOCKED #${S.lockCount}\n+$${lockAmount.toFixed(2)} locked\nTotal Protected: $${S.lockedProfit.toFixed(2)}`, 'success');
    
    save();
  }
  
  if (S.bal > S.peak) S.peak = S.bal;
  if (S.bal > S.best) S.best = S.bal;
}

function flashLockStat() {
  const el = document.getElementById('lockedStat');
  el.classList.remove('lock-flash');
  void el.offsetWidth;
  el.classList.add('lock-flash');
}

function checkTradingMode() {
  const equity = S.bal + getUnrealized();
  const dailyPct = ((equity - S.dailyStartBal) / S.dailyStartBal) * 100;
  
  if (new Date().toDateString() !== dayStart) {
    dayStart = new Date().toDateString();
    dailyPnL = 0;
    S.dailyStartBal = S.bal;
    bridgeConfig.signalsToday = 0;
    tradingMode = 'NORMAL';
    log('üìÖ New trading day', 'b');
    sendAlert('üìÖ New Trading Day Started\nLocked profits preserved: $' + S.lockedProfit.toFixed(2));
  }
  
  if (dailyPct <= -C.dailyLossLimit) {
    if (tradingMode !== 'LOCKED') {
      tradingMode = 'LOCKED';
      log('üîí LOCKED - Daily loss limit', 'r');
      sendAlert('üîí TRADING LOCKED\nDaily loss limit reached', 'error');
    }
    return false;
  }
  
  const minEquity = C.start + S.lockedProfit;
  if (equity < minEquity && S.lockedProfit > 0) {
    if (tradingMode !== 'LOCKED') {
      tradingMode = 'LOCKED';
      log(`üîí FLOOR TRIGGERED - Protecting $${S.lockedProfit.toFixed(2)}`, 'gold');
      sendAlert(`üîí PROFIT FLOOR TRIGGERED\nProtecting $${S.lockedProfit.toFixed(2)} (${S.lockCount} locks)`, 'warning');
      closeAllPositions('FLOOR');
    }
    return false;
  }
  
  if (dailyPct >= C.dailyTarget && tradingMode === 'NORMAL') {
    tradingMode = 'DEFENSIVE';
    log(`üõ°Ô∏è DEFENSIVE MODE - ${C.dailyTarget}% reached!`, 'gold');
    sendAlert(`üõ°Ô∏è DEFENSIVE MODE ACTIVATED\nDaily target of ${C.dailyTarget}% reached!`, 'success');
  }
  
  const modeEl = document.getElementById('mode');
  if (tradingMode === 'LOCKED') {
    modeEl.textContent = 'MODE:üîí';
    modeEl.className = 'badge off';
  } else if (tradingMode === 'DEFENSIVE') {
    modeEl.textContent = 'MODE:üõ°Ô∏è';
    modeEl.className = 'badge gold';
  } else {
    modeEl.textContent = 'MODE:‚ö°';
    modeEl.className = 'badge on';
  }
  
  return tradingMode !== 'LOCKED';
}

function closeAllPositions(reason) {
  S.pos.forEach(pos => {
    const p = prices[pos.sym];
    if (!p) return;
    
    const isBuy = pos.type === 'BUY';
    const cur = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    const pnl = pips * pos.pipValue;
    
    S.bal += pnl;
    dailyPnL += pnl;
    
    if (pnl > 0) { S.wins++; S.grossWin += pnl; }
    else { S.losses++; S.grossLoss += Math.abs(pnl); }
    
    // Forward close signal
    const signalData = {
      action: 'CLOSE',
      id: pos.id,
      symbol: pos.sym,
      direction: pos.type,
      exitPrice: cur,
      reason: reason,
      pips: pips,
      pnl: pnl,
      duration: Date.now() - pos.time,
      lot: pos.lot,
      sl: pos.sl,
      tp: pos.tp
    };
    sendTelegramSignal(signalData);
    sendMT5Signal(signalData);
    
    log(`üîí ${reason} ${pos.sym} ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`, pnl >= 0 ? 'g' : 'r');
  });
  
  S.pos = [];
  save();
}

function checkRiskShield() {
  const equity = S.bal + getUnrealized();
  const dd = (S.peak - equity) / S.peak * 100;
  const heat = (S.pos.length / C.maxPos) * 100;
  
  document.getElementById('dd').textContent = dd.toFixed(1) + '%';
  document.getElementById('heatBar').style.width = heat + '%';
  document.getElementById('todayPnl').textContent = (dailyPnL >= 0 ? '+$' : '-$') + Math.abs(dailyPnL).toFixed(2);
  document.getElementById('todayPnl').className = dailyPnL >= 0 ? 'g' : 'r';
  
  if (dd >= C.maxDD) {
    document.getElementById('shield').textContent = 'SHIELD:üõë';
    document.getElementById('shield').className = 'badge off';
    return false;
  }
  
  document.getElementById('shield').textContent = 'SHIELD:‚úì';
  document.getElementById('shield').className = 'badge on';
  return true;
}

function calcLotSize(sym) {
  const vol = calcVolatility(sym);
  const p = prices[sym];
  const volFactor = p ? Math.max(0.5, 1 - vol / p.mid * 100) : 1;
  const streakFactor = S.streak < -2 ? 0.5 : 1;
  const modeFactor = tradingMode === 'DEFENSIVE' ? 0.5 : 1;
  const lot = Math.max(0.01, Math.min(0.05, C.baseLot * volFactor * streakFactor * modeFactor));
  document.getElementById('lotSize').textContent = lot.toFixed(2);
  return lot;
}

function getUnrealized() {
  let u = 0;
  S.pos.forEach(pos => {
    const p = prices[pos.sym];
    if (!p) return;
    const cur = pos.type === 'BUY' ? p.bid : p.ask;
    const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    u += pips * pos.pipValue;
  });
  return u;
}

function hasCorrelatedPosition(sym) {
  const corr = getCorrelatedPairs(sym);
  return S.pos.some(p => corr.includes(p.sym) || p.sym === sym);
}

function generateTradeId() {
  return 'HFT-' + Date.now().toString(36).toUpperCase() + '-' + Math.random().toString(36).substring(2, 6).toUpperCase();
}

// =====================================================
// TRADING ENGINE
// =====================================================
function trade() {
  updateProfitLock();
  if (!checkTradingMode()) return;
  if (!checkRiskShield()) return;
  
  const now = Date.now();
  
  if (tradingMode === 'NORMAL' || (tradingMode === 'DEFENSIVE' && S.pos.length < 2)) {
    SYM.forEach(sym => {
      const p = prices[sym.s];
      if (!p) return;
      
      if (lastTrade[sym.s] && now - lastTrade[sym.s] < C.cooldown) return;
      if (hasCorrelatedPosition(sym.s)) return;
      if (S.pos.length >= C.maxPos) return;
      
      const { sig, strength, rsi, ecbBias } = getSignal(sym.s);
      
      if (sig) {
        const lot = calcLotSize(sym.s);
        const pipValue = lot * (sym.s.includes('JPY') ? 100 : 10);
        const isBuy = sig === 'BUY';
        const entry = isBuy ? p.ask : p.bid;
        const tradeId = generateTradeId();
        
        const newPos = {
          id: tradeId,
          sym: sym.s,
          type: sig,
          entry,
          tp: isBuy ? entry + C.tp * sym.p : entry - C.tp * sym.p,
          sl: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
          originalSL: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
          trail: null,
          trailLevel: 0,
          partialClosed: false,
          pipValue,
          originalPipValue: pipValue,
          pip: sym.p,
          lot,
          originalLot: lot,
          strength,
          entryRSI: rsi,
          ecbBias,
          time: now,
          maxPips: 0
        };
        
        S.pos.push(newPos);
        lastTrade[sym.s] = now;
        
        // Forward signal to Telegram + MT5
        const signalData = {
          action: 'OPEN',
          id: tradeId,
          symbol: sym.s,
          direction: sig,
          entry: entry,
          tp: newPos.tp,
          sl: newPos.sl,
          lot: lot,
          strength: strength
        };
        sendTelegramSignal(signalData);
        sendMT5Signal(signalData);
        
        const biasIcon = ecbBias > 0 ? 'ü¶Ö' : ecbBias < 0 ? 'üïäÔ∏è' : '‚öñÔ∏è';
        log(`${sig} ${sym.s} @${fmtPrice(sym.s, entry)} [${strength}‚òÖ] ${biasIcon}`, sig === 'BUY' ? 'g' : 'r');
      }
    });
  }
  
  managePositions();
}

function managePositions() {
  const now = Date.now();
  const toClose = [];
  
  S.pos.forEach((pos, i) => {
    const p = prices[pos.sym];
    if (!p) return;
    
    const isBuy = pos.type === 'BUY';
    const cur = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    
    if (pips > pos.maxPips) pos.maxPips = pips;
    
    // Break-Even
    if (pips >= C.breakEvenTrigger && pos.trailLevel < 1) {
      pos.trailLevel = 1;
      pos.trail = isBuy ? pos.entry + C.breakEvenPlus * pos.pip : pos.entry - C.breakEvenPlus * pos.pip;
      log(`üîí BE ${pos.sym} +${pips.toFixed(1)}p`, 'gold');
    }
    
    // Trail levels
    if (pips >= C.trail1Trigger && pos.trailLevel < 2) {
      pos.trailLevel = 2;
      log(`üìç TRAIL1 ${pos.sym}`, 'y');
    }
    if (pips >= C.trail2Trigger && pos.trailLevel < 3) {
      pos.trailLevel = 3;
      log(`üìç TRAIL2 ${pos.sym}`, 'y');
    }
    if (pips >= C.trail3Trigger && pos.trailLevel < 4) {
      pos.trailLevel = 4;
      log(`üìç TRAIL3 ${pos.sym}`, 'y');
    }
    
    // Update trailing stop
    if (pos.trailLevel >= 2) {
      const trailDist = pos.trailLevel === 4 ? C.trail3Distance : 
                        pos.trailLevel === 3 ? C.trail2Distance : C.trail1Distance;
      const newTrail = isBuy ? cur - trailDist * pos.pip : cur + trailDist * pos.pip;
      if (isBuy && (!pos.trail || newTrail > pos.trail)) pos.trail = newTrail;
      if (!isBuy && (!pos.trail || newTrail < pos.trail)) pos.trail = newTrail;
    }
    
    // Partial close
    if (pips >= C.partial1Trigger && !pos.partialClosed) {
      const partialPnl = pips * pos.pipValue * C.partial1Pct;
      S.bal += partialPnl;
      dailyPnL += partialPnl;
      pos.pipValue *= (1 - C.partial1Pct);
      pos.lot *= (1 - C.partial1Pct);
      pos.partialClosed = true;
      log(`‚úÇÔ∏è PARTIAL ${pos.sym} +$${partialPnl.toFixed(2)}`, 'g');
    }
    
    // Exit conditions
    let closeReason = null;
    
    // TP hit
    if ((isBuy && cur >= pos.tp) || (!isBuy && cur <= pos.tp)) {
      closeReason = 'TP';
    }
    // SL hit
    else if ((isBuy && cur <= pos.sl) || (!isBuy && cur >= pos.sl)) {
      closeReason = 'SL';
    }
    // Trail hit
    else if (pos.trail && ((isBuy && cur <= pos.trail) || (!isBuy && cur >= pos.trail))) {
      closeReason = pos.trailLevel >= 2 ? 'TRAIL' : 'BE';
    }
    // Max hold time
    else if (now - pos.time > C.maxHoldTime) {
      closeReason = 'TIME';
    }
    // Stagnant check
    else if (now - pos.time > 60000 && Math.abs(pips) < C.stagnantThreshold) {
      const mom = Math.abs(parseFloat(calcMomentum(pos.sym)));
      if (mom < C.momentumExitThreshold) {
        closeReason = 'STAG';
      }
    }
    // RSI reversal
    else if (pips > 2) {
      const rsi = calcRSI(pos.sym);
      if ((isBuy && rsi > C.maxRSI - C.rsiExitBuffer) || (!isBuy && rsi < C.minRSI + C.rsiExitBuffer)) {
        closeReason = 'RSI';
      }
    }
    
    if (closeReason) {
      toClose.push({ i, pos, cur, pips, reason: closeReason });
    }
  });
  
  // Close positions
  toClose.sort((a, b) => b.i - a.i).forEach(({ i, pos, cur, pips, reason }) => {
    const pnl = pips * pos.pipValue;
    S.bal += pnl;
    dailyPnL += pnl;
    S.returns.push(pnl / S.bal * 100);
    
    if (pnl > 0) {
      S.wins++;
      S.grossWin += pnl;
      S.streak = S.streak >= 0 ? S.streak + 1 : 1;
    } else {
      S.losses++;
      S.grossLoss += Math.abs(pnl);
      S.streak = S.streak <= 0 ? S.streak - 1 : -1;
    }
    
    // Forward close signal
    const signalData = {
      action: 'CLOSE',
      id: pos.id,
      symbol: pos.sym,
      direction: pos.type,
      exitPrice: cur,
      reason: reason,
      pips: pips,
      pnl: pnl,
      duration: Date.now() - pos.time,
      lot: pos.lot,
      sl: pos.sl,
      tp: pos.tp
    };
    sendTelegramSignal(signalData);
    sendMT5Signal(signalData);
    
    const emoji = reason === 'TP' ? 'üéØ' : reason === 'TRAIL' ? 'üìà' : reason === 'BE' ? 'üîí' : reason === 'SL' ? '‚ùå' : '‚è±Ô∏è';
    log(`${emoji} ${reason} ${pos.sym} ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pips.toFixed(1)}p)`, pnl >= 0 ? 'g' : 'r');
    
    S.pos.splice(i, 1);
  });
  
  save();
}

// =====================================================
// UI HELPERS
// =====================================================
function fmtPrice(sym, price) {
  const symData = SYM.find(s => s.s === sym);
  return price.toFixed(symData && symData.p === 0.01 ? 2 : 5);
}

function log(msg, cls = '') {
  const entry = { msg, cls, t: Date.now() };
  logs.unshift(entry);
  if (logs.length > 50) logs.pop();
}

function renderLog() {
  const el = document.getElementById('log');
  el.innerHTML = logs.slice(0, 15).map(l => 
    `<div class="log ${l.cls}">${new Date(l.t).toLocaleTimeString().slice(0, 8)} ${l.msg}</div>`
  ).join('');
}

function renderMarket() {
  const el = document.getElementById('market');
  el.innerHTML = SYM.map(sym => {
    const p = prices[sym.s];
    if (!p) return '';
    const { sig, strength, rsi, mom, ecbBias } = getSignal(sym.s);
    const pos = S.pos.find(ps => ps.sym === sym.s);
    let pnlStr = '--';
    let pnlCls = 'dim';
    
    if (pos) {
      const cur = pos.type === 'BUY' ? p.bid : p.ask;
      const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
      const pnl = pips * pos.pipValue;
      pnlStr = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
      pnlCls = pnl >= 0 ? 'g' : 'r';
    }
    
    const biasIcon = ecbBias > 0 ? 'ü¶Ö' : ecbBias < 0 ? 'üïäÔ∏è' : '‚öñÔ∏è';
    const sigStr = sig ? `<span class="${sig === 'BUY' ? 'g' : 'r'}">${sig}</span>` : '<span class="dim">--</span>';
    const rsiCls = rsi < 30 ? 'g' : rsi > 70 ? 'r' : 'dim';
    const momCls = parseFloat(mom) > 0 ? 'g' : parseFloat(mom) < 0 ? 'r' : 'dim';
    
    return `<tr>
      <td><b>${sym.s}</b> <span class="dim">${sym.t.charAt(0).toUpperCase()}</span></td>
      <td>${fmtPrice(sym.s, p.bid)}</td>
      <td>${fmtPrice(sym.s, p.ask)}</td>
      <td class="${p.spread > 2.5 ? 'r' : 'dim'}">${p.spread.toFixed(1)}</td>
      <td class="${rsiCls}">${rsi}</td>
      <td class="${momCls}">${mom}</td>
      <td>${biasIcon}</td>
      <td>${sigStr} ${strength > 0 ? '<span class="dim">‚òÖ' + strength + '</span>' : ''}</td>
      <td class="${pnlCls}">${pnlStr}</td>
    </tr>`;
  }).join('');
}

function renderPositions() {
  const el = document.getElementById('positions');
  if (S.pos.length === 0) {
    el.innerHTML = '<span class="dim">No open positions</span>';
    return;
  }
  
  el.innerHTML = S.pos.map(pos => {
    const p = prices[pos.sym];
    if (!p) return '';
    const cur = pos.type === 'BUY' ? p.bid : p.ask;
    const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    const pnl = pips * pos.pipValue;
    const dur = Math.round((Date.now() - pos.time) / 1000);
    const trailInfo = pos.trailLevel > 0 ? `T${pos.trailLevel}` : '';
    
    return `<div class="log" style="display:flex;justify-content:space-between">
      <span class="${pos.type === 'BUY' ? 'g' : 'r'}">${pos.type} ${pos.sym}</span>
      <span class="dim">${pos.lot.toFixed(2)}L ${dur}s ${trailInfo}</span>
      <span class="${pnl >= 0 ? 'g' : 'r'}">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pips.toFixed(1)}p)</span>
    </div>`;
  }).join('');
}

function renderChart() {
  const el = document.getElementById('chart');
  const eq = S.eq.slice(-40);
  if (eq.length < 2) return;
  
  const min = Math.min(...eq) * 0.995;
  const max = Math.max(...eq) * 1.005;
  const range = max - min || 1;
  
  el.innerHTML = eq.map((v, i) => {
    const h = ((v - min) / range) * 100;
    const color = v >= C.start ? 'var(--g)' : 'var(--r)';
    return `<div style="height:${h}%;background:${color}"></div>`;
  }).join('');
}

function renderStats() {
  const equity = S.bal + getUnrealized();
  const pnlPct = ((equity - C.start) / C.start * 100);
  const total = S.wins + S.losses;
  const winRate = total > 0 ? (S.wins / total * 100) : 0;
  const pf = S.grossLoss > 0 ? (S.grossWin / S.grossLoss) : S.grossWin > 0 ? 999 : 0;
  const dd = S.peak > 0 ? ((S.peak - equity) / S.peak * 100) : 0;
  
  // Sharpe ratio (simplified)
  let sharpe = 0;
  if (S.returns.length > 5) {
    const mean = S.returns.reduce((a, b) => a + b, 0) / S.returns.length;
    const variance = S.returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / S.returns.length;
    const stdDev = Math.sqrt(variance);
    sharpe = stdDev > 0 ? (mean / stdDev * Math.sqrt(252)) : 0;
  }
  
  document.getElementById('equity').textContent = '$' + equity.toFixed(2);
  document.getElementById('equity').className = equity >= C.start ? 'g' : 'r';
  document.getElementById('pnlPct').textContent = (pnlPct >= 0 ? '+' : '') + pnlPct.toFixed(2) + '%';
  document.getElementById('pnlPct').className = pnlPct >= 0 ? 'g' : 'r';
  document.getElementById('locked').textContent = '$' + S.lockedProfit.toFixed(2);
  document.getElementById('lockPct').textContent = S.lockCount + ' locks';
  document.getElementById('trades').textContent = total;
  document.getElementById('winrate').textContent = winRate.toFixed(0) + '%';
  document.getElementById('pf').textContent = pf.toFixed(2);
  document.getElementById('openPos').textContent = S.pos.length + '/' + C.maxPos;
  document.getElementById('streak').textContent = (S.streak > 0 ? '+' : '') + S.streak;
  document.getElementById('streak').className = S.streak > 0 ? 'g' : S.streak < 0 ? 'r' : '';
  document.getElementById('best').textContent = '$' + S.best.toFixed(0);
  document.getElementById('dd').textContent = dd.toFixed(1) + '%';
  document.getElementById('sharpe').textContent = sharpe.toFixed(2);
  
  // Progress bars
  const dailyPct = ((equity - S.dailyStartBal) / S.dailyStartBal) * 100;
  const targetPct = Math.min(100, Math.max(0, (dailyPct / C.dailyTarget) * 100));
  document.getElementById('targetBar').style.width = targetPct + '%';
  
  const nextLock = S.lastLockLevel + C.profitLockStep;
  const lockProgress = Math.min(100, Math.max(0, ((equity - S.lastLockLevel) / C.profitLockStep) * 100));
  document.getElementById('nextLockAt').textContent = '$' + nextLock.toFixed(0);
  document.getElementById('lockBar').style.width = lockProgress + '%';
  
  document.getElementById('lockStep').textContent = '$' + C.profitLockStep;
  document.getElementById('lockPctStat').textContent = C.profitLockPct + '%';
  document.getElementById('lockCount').textContent = S.lockCount;
  
  // Record equity
  if (S.eq.length === 0 || S.eq[S.eq.length - 1] !== equity) {
    S.eq.push(equity);
    if (S.eq.length > 100) S.eq.shift();
  }
}

function render() {
  document.getElementById('time').textContent = new Date().toLocaleTimeString();
  renderStats();
  renderMarket();
  renderPositions();
  renderChart();
  renderLog();
}

// =====================================================
// MAIN LOOP
// =====================================================
async function init() {
  document.getElementById('status').textContent = 'INIT';
  document.getElementById('status').className = 'badge warn pulse';
  
  log('üöÄ HFT ULTRA FX 2026 Starting...', 'b');
  
  await fetchECBRates();
  updateBridgeUI();
  
  // Initial price population
  for (let i = 0; i < 30; i++) {
    updatePrices();
  }
  
  document.getElementById('status').textContent = 'LIVE';
  document.getElementById('status').className = 'badge on pulse';
  log('‚úÖ System online - 28 pairs active', 'g');
  
  // Send startup alert
  if (bridgeConfig.telegramToken && bridgeConfig.telegramChatId) {
    sendAlert(`üöÄ HFT ULTRA FX 2026 ONLINE\nüí∞ Balance: $${S.bal.toFixed(2)}\nüîí Locked: $${S.lockedProfit.toFixed(2)}\nüìä 28 pairs monitoring`, 'success');
  }
  
  // Main loop
  setInterval(() => {
    updatePrices();
    trade();
    render();
  }, 500);
  
  // ECB rate refresh
  setInterval(fetchECBRates, 300000);
  
  // Auto-save
  setInterval(save, 30000);
}

init();
</script>
</body>
</html>
