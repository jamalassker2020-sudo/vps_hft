<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>FOREX ULTRA 2026 - Telegram Bridge</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0e14;--card:#121820;--border:#1a2030;--txt:#c8d0dc;--dim:#5a6270;--g:#0f6;--r:#f44;--b:#0af;--y:#fc0}
html.light{--bg:#f4f6f8;--card:#fff;--border:#dde;--txt:#1a1a2e;--dim:#888}
body{background:var(--bg);color:var(--txt);font:11px/1.4 monospace;padding:8px;min-height:100vh}
.g{color:var(--g)}.r{color:var(--r)}.b{color:var(--b)}.y{color:var(--y)}.dim{color:var(--dim)}
.card{background:var(--card);border:1px solid var(--border);border-radius:4px;padding:8px;margin-bottom:8px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.col{flex:1;min-width:120px}
.grid{display:grid;gap:4px}
.g2{grid-template-columns:repeat(2,1fr)}.g3{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(4,1fr)}.g6{grid-template-columns:repeat(6,1fr)}
.stat{background:var(--bg);padding:6px;border-radius:3px;text-align:center}
.stat small{display:block;font-size:9px;color:var(--dim);margin-bottom:2px}
.stat b{font-size:13px}
h1{font-size:14px;margin-bottom:4px}
table{width:100%;border-collapse:collapse;font-size:10px}
th,td{padding:4px;text-align:right}
th{color:var(--dim);font-weight:400;border-bottom:1px solid var(--border)}
td:first-child,th:first-child{text-align:left}
tr:hover{background:rgba(255,255,255,.02)}
.scroll{max-height:200px;overflow-y:auto}
.bar{height:40px;display:flex;align-items:end;gap:1px}
.bar div{flex:1;min-width:2px;border-radius:1px 1px 0 0}
.log{font-size:9px;padding:2px 4px;margin:1px 0;border-radius:2px;background:var(--bg)}
button{background:var(--card);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;cursor:pointer;font:inherit}
button:hover{background:var(--border)}
.pulse{animation:p 1.5s infinite}@keyframes p{50%{opacity:.5}}
.badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px}
.badge.on{background:#0f62;color:var(--g)}.badge.off{background:#f442;color:var(--r)}.badge.warn{background:#fc02;color:var(--y)}
input[type="text"]{background:var(--bg);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;font:inherit;width:100%;font-size:16px}
input[type="text"]:focus{outline:none;border-color:var(--b)}
.webhook-status{font-size:9px;margin-top:4px}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:400px;width:90%}
.modal h3{margin-bottom:12px;font-size:14px}
.modal-buttons{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
@media(max-width:600px){.g6{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>
<div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
<div>
<h1>‚ö° FOREX ULTRA <span class="dim">2026</span> <span class="y">[TELEGRAM BRIDGE]</span></h1>
<small class="dim">28 FX PAIRS ‚Ä¢ REAL FOREX DATA ‚Ä¢ TELEGRAM ‚Üí MT5 BRIDGE ‚Ä¢ ECB SIGNALS</small>
</div>
<div class="row" style="gap:4px">
<span id="status" class="badge pulse">INIT</span>
<span id="api" class="badge dim">API:--</span>
<span id="telegramStatus" class="badge dim">TG:--</span>
<span id="shield" class="badge">SHIELD:--</span>
<button onclick="showTelegramConfig()">‚öôÔ∏è</button>
<button onclick="reset()">‚ü≤</button>
</div>
</div>

<div class="grid g6" style="margin-bottom:8px">
<div class="stat"><small>üí∞ EQUITY</small><b id="equity" class="g">$100.00</b><div id="pnlPct" style="font-size:9px">+0.00%</div></div>
<div class="stat"><small>P&L</small><b id="pnl">$0.00</b></div>
<div class="stat"><small>TRADES</small><b id="trades" class="b">0</b></div>
<div class="stat"><small>WIN%</small><b id="winrate" class="y">0%</b></div>
<div class="stat"><small>PROFIT F.</small><b id="pf" class="g">0.00</b></div>
<div class="stat"><small>OPEN</small><b id="openPos" class="b">0/6</b></div>
<div class="stat"><small>STREAK</small><b id="streak">0</b></div>
<div class="stat"><small>BEST</small><b id="best" class="g">$100</b></div>
<div class="stat"><small>DD</small><b id="dd" class="r">0%</b></div>
<div class="stat"><small>AVG WIN</small><b id="avgWin" class="g">$0</b></div>
<div class="stat"><small>AVG LOSS</small><b id="avgLoss" class="r">$0</b></div>
<div class="stat"><small>SIGNALS SENT</small><b id="signalsSent" class="b">0</b></div>
</div>

<div class="row">
<div class="col" style="flex:3">
<div class="card">
<div class="row" style="justify-content:space-between;margin-bottom:4px">
<b class="b">üìä FOREX MARKET</b>
<span id="time" class="dim">--:--:--</span>
</div>
<div class="scroll"><table><thead><tr><th>SYM</th><th>BID</th><th>ASK</th><th>Œî</th><th>RSI</th><th>MOM</th><th>ECB BIAS</th><th>SIG</th><th>P&L</th></tr></thead><tbody id="market"></tbody></table></div>
</div>
</div>
<div class="col">
<div class="card">
<b>üìà POSITIONS</b>
<div id="positions" class="scroll" style="margin-top:4px"><span class="dim">Scanning...</span></div>
</div>
<div class="card">
<b>‚ö° LOG</b>
<div id="log" class="scroll" style="margin-top:4px"><span class="dim">Starting...</span></div>
</div>
</div>
</div>

<div class="row">
<div class="col">
<div class="card"><b>üíπ EQUITY</b><div class="bar" id="chart"></div></div>
</div>
<div class="col">
<div class="card">
<b>ü§ñ TELEGRAM BRIDGE</b>
<div class="grid g3" style="margin-top:6px;font-size:9px;text-align:center">
<div class="stat"><small>BOT STATUS</small><span id="botStatus" class="y">OFFLINE</span></div>
<div class="stat"><small>SIGNALS TODAY</small><span id="signalsToday">0</span></div>
<div class="stat"><small>CHAT ID</small><span id="chatIdDisplay">--</span></div>
<div class="stat"><small>LAST SIGNAL</small><span id="lastSignalTime">--:--</span></div>
<div class="stat"><small>SUCCESS RATE</small><span id="successRate" class="g">100%</span></div>
<div class="stat"><small>LOT SIZE</small><span id="lotSize" class="b">0.01</span></div>
</div>
</div>
</div>
</div>

<!-- Telegram Config Modal -->
<div id="telegramModal" class="modal-overlay" style="display:none">
<div class="modal">
<h3>ü§ñ TELEGRAM BRIDGE CONFIGURATION</h3>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">1. Telegram Bot Token</label>
<input type="text" id="telegramToken" placeholder="1234567890:ABCdefGHIjklMNopQRstuVWXyz" value="8488789199:AAHhViKmhXlve7WpgZGvDS4wjCju">
<small class="dim">Get from @BotFather on Telegram</small>
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">2. Your Chat ID</label>
<input type="text" id="telegramChatId" placeholder="123456789" value="93372553">
<small class="dim">Send /start to @userinfobot to get your ID</small>
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">3. MT5 EA Webhook URL</label>
<input type="text" id="mt5WebhookUrl" placeholder="http://192.168.1.100:24843/webhook" value="https://docker-metatrader-production.up.railway.app/">
<small class="dim">Your MT5 Expert Advisor endpoint (TelegramToMT5 EA)</small>
</div>
<div class="grid g2" style="margin-bottom:12px">
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgSignalEnabled" checked> Send Trading Signals
</label>
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgAlertEnabled" checked> Send Alerts
</label>
</div>
<div class="webhook-status" id="telegramTestResult"></div>
<div class="modal-buttons">
<button onclick="testTelegramConnection()">üß™ Test Telegram</button>
<button onclick="testMT5Connection()">üîó Test MT5</button>
<button onclick="saveTelegramConfig()">üíæ Save</button>
<button onclick="closeTelegramModal()">‚úï Close</button>
</div>
</div>
</div>

<script>
// =====================================================
// TELEGRAM BRIDGE CONFIGURATION
// =====================================================
const telegramConfig = {
    botToken: '8488789199:AAHhViKmhXlve7WpgZGvDS4wjCju',
    chatId: '93372553',
    mt5WebhookUrl: 'https://docker-metatrader-production.up.railway.app/',
    signalEnabled: true,
    alertEnabled: true,
    signalsSent: 0,
    signalsToday: 0,
    lastSignalTime: null,
    successCount: 0,
    errorCount: 0
};

// =====================================================
// FOREX INSTRUMENTS (28 pairs + XAUUSD)
// =====================================================
const SYM = [
    // Major Pairs
    {s:'EUR/USD', b:'EURUSD', p:0.00001, t:'major', mt5:'EURUSD', pipFactor:10000},
    {s:'GBP/USD', b:'GBPUSD', p:0.00001, t:'major', mt5:'GBPUSD', pipFactor:10000},
    {s:'USD/JPY', b:'USDJPY', p:0.001, t:'major', mt5:'USDJPY', pipFactor:100},
    {s:'USD/CHF', b:'USDCHF', p:0.00001, t:'major', mt5:'USDCHF', pipFactor:10000},
    {s:'AUD/USD', b:'AUDUSD', p:0.00001, t:'major', mt5:'AUDUSD', pipFactor:10000},
    {s:'USD/CAD', b:'USDCAD', p:0.00001, t:'major', mt5:'USDCAD', pipFactor:10000},
    {s:'NZD/USD', b:'NZDUSD', p:0.00001, t:'major', mt5:'NZDUSD', pipFactor:10000},
    
    // Crosses
    {s:'EUR/GBP', b:'EURGBP', p:0.00001, t:'cross', mt5:'EURGBP', pipFactor:10000},
    {s:'EUR/JPY', b:'EURJPY', p:0.001, t:'cross', mt5:'EURJPY', pipFactor:100},
    {s:'GBP/JPY', b:'GBPJPY', p:0.001, t:'cross', mt5:'GBPJPY', pipFactor:100},
    {s:'EUR/CHF', b:'EURCHF', p:0.00001, t:'cross', mt5:'EURCHF', pipFactor:10000},
    {s:'EUR/AUD', b:'EURAUD', p:0.00001, t:'cross', mt5:'EURAUD', pipFactor:10000},
    {s:'EUR/CAD', b:'EURCAD', p:0.00001, t:'cross', mt5:'EURCAD', pipFactor:10000},
    {s:'GBP/AUD', b:'GBPAUD', p:0.00001, t:'cross', mt5:'GBPAUD', pipFactor:10000},
    {s:'GBP/CAD', b:'GBPCAD', p:0.00001, t:'cross', mt5:'GBPCAD', pipFactor:10000},
    {s:'AUD/JPY', b:'AUDJPY', p:0.001, t:'cross', mt5:'AUDJPY', pipFactor:100},
    {s:'CAD/JPY', b:'CADJPY', p:0.001, t:'cross', mt5:'CADJPY', pipFactor:100},
    {s:'NZD/JPY', b:'NZDJPY', p:0.001, t:'cross', mt5:'NZDJPY', pipFactor:100},
    {s:'AUD/CAD', b:'AUDCAD', p:0.00001, t:'cross', mt5:'AUDCAD', pipFactor:10000},
    {s:'AUD/NZD', b:'AUDNZD', p:0.00001, t:'cross', mt5:'AUDNZD', pipFactor:10000},
    {s:'CAD/CHF', b:'CADCHF', p:0.00001, t:'cross', mt5:'CADCHF', pipFactor:10000},
    {s:'CHF/JPY', b:'CHFJPY', p:0.001, t:'cross', mt5:'CHFJPY', pipFactor:100},
    
    // Commodities
    {s:'XAU/USD', b:'XAUUSD', p:0.01, t:'commodity', mt5:'XAUUSD', pipFactor:100},
    {s:'XAG/USD', b:'XAGUSD', p:0.0001, t:'commodity', mt5:'XAGUSD', pipFactor:10000},
    
    // Exotics
    {s:'USD/SGD', b:'USDSGD', p:0.00001, t:'exotic', mt5:'USDSGD', pipFactor:10000},
    {s:'USD/HKD', b:'USDHKD', p:0.00001, t:'exotic', mt5:'USDHKD', pipFactor:10000},
    {s:'USD/MXN', b:'USDMXN', p:0.0001, t:'exotic', mt5:'USDMXN', pipFactor:1000},
    {s:'USD/TRY', b:'USDTRY', p:0.0001, t:'exotic', mt5:'USDTRY', pipFactor:1000}
];

// ECB Interest Rates and Central Bank Bias
const ECB_BIAS = {
    'EUR': {rate: 4.0, bias: 'hawkish', lastMeeting: '2024-01-25'},
    'USD': {rate: 5.5, bias: 'hawkish', lastMeeting: '2024-01-31'},
    'GBP': {rate: 5.25, bias: 'hawkish', lastMeeting: '2024-02-01'},
    'JPY': {rate: -0.1, bias: 'dovish', lastMeeting: '2024-01-23'},
    'CHF': {rate: 1.75, bias: 'neutral', lastMeeting: '2024-12-14'},
    'CAD': {rate: 5.0, bias: 'neutral', lastMeeting: '2024-01-24'},
    'AUD': {rate: 4.35, bias: 'neutral', lastMeeting: '2024-02-06'},
    'NZD': {rate: 5.5, bias: 'hawkish', lastMeeting: '2024-02-28'}
};

// =====================================================
// TRADING CONFIGURATION
// =====================================================
const C = {
    start: 100,
    baseLot: 0.01,
    tp: 20,           // 20 pip TP
    sl: 10,           // 10 pip SL
    trail: 8,         // Trail after 8 pips
    maxPos: 6,
    maxDD: 5,
    dailyLossLimit: 3,
    cooldown: 5000,
    rsiPeriod: 14,
    minRSI: 25,
    maxRSI: 75,
    minStrength: 3,
    spreadMax: 2,
    corrThreshold: 0.7,
    // Economic calendar filter
    newsImpact: ['high', 'medium'],  // Only trade high/medium impact news
    newsCooldown: 3600000,  // 1 hour before/after major news
    // ECB data refresh
    ecbRefresh: 300000  // 5 minutes
};

// =====================================================
// TELEGRAM BRIDGE FUNCTIONS
// =====================================================
function loadTelegramConfig() {
    try {
        const hash = location.hash.slice(1);
        if (hash) {
            const data = JSON.parse(atob(hash));
            if (data.telegramConfig) {
                Object.assign(telegramConfig, data.telegramConfig);
            }
        }
    } catch (e) {
        console.log('No Telegram config found');
    }
    updateTelegramUI();
}

function saveTelegramConfig() {
    telegramConfig.botToken = document.getElementById('telegramToken').value.trim();
    telegramConfig.chatId = document.getElementById('telegramChatId').value.trim();
    telegramConfig.mt5WebhookUrl = document.getElementById('mt5WebhookUrl').value.trim();
    telegramConfig.signalEnabled = document.getElementById('tgSignalEnabled').checked;
    telegramConfig.alertEnabled = document.getElementById('tgAlertEnabled').checked;
    
    save(); // Save to URL hash
    updateTelegramUI();
    closeTelegramModal();
    log('ü§ñ Telegram config saved', 'b');
}

function showTelegramConfig() {
    document.getElementById('telegramToken').value = telegramConfig.botToken;
    document.getElementById('telegramChatId').value = telegramConfig.chatId;
    document.getElementById('mt5WebhookUrl').value = telegramConfig.mt5WebhookUrl;
    document.getElementById('tgSignalEnabled').checked = telegramConfig.signalEnabled;
    document.getElementById('tgAlertEnabled').checked = telegramConfig.alertEnabled;
    document.getElementById('telegramModal').style.display = 'flex';
}

function closeTelegramModal() {
    document.getElementById('telegramModal').style.display = 'none';
}

async function testTelegramConnection() {
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    const resultEl = document.getElementById('telegramTestResult');
    
    if (!token || !chatId) {
        resultEl.innerHTML = '<span class="r">‚ùå Enter Token & Chat ID</span>';
        return;
    }
    
    resultEl.innerHTML = '<span class="y">üîÑ Testing Telegram connection...</span>';
    
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
        const data = await response.json();
        
        if (data.ok) {
            resultEl.innerHTML = `<span class="g">‚úÖ Bot connected: ${data.result.username}</span>`;
            
            // Send test message
            setTimeout(async () => {
                try {
                    await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            chat_id: chatId,
                            text: '‚úÖ FOREX ULTRA 2026 Telegram Bridge Connected!\nSystem ready to forward ECB-based signals to MT5.'
                        })
                    });
                    log('‚úÖ Telegram test successful', 'g');
                } catch (msgErr) {
                    log(`‚ö†Ô∏è Could not send test message: ${msgErr.message}`, 'y');
                }
            }, 500);
        } else {
            resultEl.innerHTML = `<span class="r">‚ùå Invalid bot token</span>`;
        }
    } catch (err) {
        resultEl.innerHTML = `<span class="r">‚ùå Connection failed: ${err.message}</span>`;
    }
}

async function testMT5Connection() {
    const mt5Url = document.getElementById('mt5WebhookUrl').value.trim();
    const resultEl = document.getElementById('telegramTestResult');
    
    if (!mt5Url) {
        resultEl.innerHTML = '<span class="r">‚ùå Enter MT5 Webhook URL</span>';
        return;
    }
    
    resultEl.innerHTML = '<span class="y">üîÑ Testing MT5 connection...</span>';
    
    // Format signal for TelegramToMT5 EA
    const testSignal = {
        action: 'OPEN',
        symbol: 'EURUSD',
        type: 'BUY',  // BUY or SELL
        price: 1.0850,
        lot: 0.01,
        sl: 1.0840,
        tp: 1.0870,
        comment: 'TG-TEST-' + Date.now(),
        magic: 2026,
        timestamp: new Date().toISOString(),
        source: 'FOREX-TELEGRAM-BRIDGE-TEST'
    };
    
    try {
        const response = await fetch(mt5Url, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testSignal)
        });
        
        if (response.ok) {
            resultEl.innerHTML = '<span class="g">‚úÖ MT5 connection successful</span>';
            log('‚úÖ MT5 test signal sent', 'g');
        } else {
            resultEl.innerHTML = '<span class="r">‚ùå MT5 responded with error</span>';
            log(`‚ö†Ô∏è MT5 test failed: ${response.status}`, 'y');
        }
    } catch (err) {
        resultEl.innerHTML = `<span class="r">‚ùå MT5 connection failed: ${err.message}</span>`;
        log(`‚ö†Ô∏è MT5 test failed: ${err.message}`, 'y');
    }
}

function updateTelegramUI() {
    const el = document.getElementById('telegramStatus');
    if (telegramConfig.botToken && telegramConfig.chatId) {
        el.textContent = 'TG:‚úì';
        el.className = 'badge on';
        document.getElementById('botStatus').textContent = 'ONLINE';
        document.getElementById('botStatus').className = 'g';
        document.getElementById('chatIdDisplay').textContent = telegramConfig.chatId.substring(0, 6) + '...';
    } else {
        el.textContent = 'TG:OFF';
        el.className = 'badge dim';
        document.getElementById('botStatus').textContent = 'OFFLINE';
        document.getElementById('botStatus').className = 'r';
    }
    
    document.getElementById('signalsSent').textContent = telegramConfig.signalsSent;
    document.getElementById('signalsToday').textContent = telegramConfig.signalsToday;
    document.getElementById('lastSignalTime').textContent = telegramConfig.lastSignalTime ? 
        telegramConfig.lastSignalTime.substring(11, 16) : '--:--';
    
    const total = telegramConfig.successCount + telegramConfig.errorCount;
    document.getElementById('successRate').textContent = total > 0 ? 
        Math.round((telegramConfig.successCount / total) * 100) + '%' : '100%';
}

// =====================================================
// SIGNAL FORWARDING SYSTEM (TelegramToMT5 EA Format)
// =====================================================
async function forwardSignalToTelegram(signalData) {
    if (!telegramConfig.signalEnabled || !telegramConfig.botToken || !telegramConfig.chatId) {
        return false;
    }
    
    // Format message for Telegram
    let message = '';
    if (signalData.action === 'OPEN') {
        const baseCurrency = signalData.symbol.substring(0, 3);
        const quoteCurrency = signalData.symbol.substring(3, 6);
        const baseBias = ECB_BIAS[baseCurrency] ? ECB_BIAS[baseCurrency].bias : 'neutral';
        const quoteBias = ECB_BIAS[quoteCurrency] ? ECB_BIAS[quoteCurrency].bias : 'neutral';
        
        message = `üöÄ <b>${signalData.type} ${signalData.symbol}</b>\n`;
        message += `üí∞ Entry: <code>${signalData.entry_price.toFixed(5)}</code>\n`;
        message += `üéØ TP: <code>${signalData.take_profit.toFixed(5)}</code> (${C.tp} pips)\n`;
        message += `üõë SL: <code>${signalData.stop_loss.toFixed(5)}</code> (${C.sl} pips)\n`;
        message += `üìä Lot: <code>${signalData.lot_size}</code>\n`;
        message += `‚ö° Strength: ${signalData.signal_strength}/5\n`;
        message += `üè¶ ECB Bias: ${baseBias.toUpperCase()} vs ${quoteBias.toUpperCase()}\n`;
        message += `üÜî ${signalData.trade_id}\n`;
        message += `üïí ${new Date(signalData.timestamp).toLocaleTimeString()}`;
    } else {
        message = `üèÅ <b>${signalData.symbol} CLOSED</b>\n`;
        message += `üìä Result: <b>${signalData.exit_reason}</b>\n`;
        message += `üí∞ P&L: <code>$${signalData.pnl_usd.toFixed(2)}</code>\n`;
        message += `üìà Pips: <code>${signalData.pnl_pips.toFixed(1)}</code>\n`;
        message += `‚è±Ô∏è Duration: ${Math.round(signalData.duration_ms / 1000)}s\n`;
        message += `üÜî ${signalData.trade_id}\n`;
        message += `üïí ${new Date(signalData.timestamp).toLocaleTimeString()}`;
    }
    
    try {
        // Send to Telegram
        const tgResponse = await fetch(`https://api.telegram.org/bot${telegramConfig.botToken}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: telegramConfig.chatId,
                text: message,
                parse_mode: 'HTML',
                disable_web_page_preview: true
            })
        });
        
        if (tgResponse.ok) {
            telegramConfig.signalsSent++;
            telegramConfig.signalsToday++;
            telegramConfig.lastSignalTime = new Date().toISOString();
            telegramConfig.successCount++;
            
            // Update UI
            updateTelegramUI();
            
            log(`üì± Telegram signal sent: ${signalData.symbol}`, 'b');
            
            // Forward to MT5 if URL is set
            if (telegramConfig.mt5WebhookUrl) {
                setTimeout(() => forwardSignalToMT5(signalData), 100);
            }
            
            return true;
        }
    } catch (err) {
        telegramConfig.errorCount++;
        log(`‚ö†Ô∏è Telegram error: ${err.message}`, 'y');
    }
    
    return false;
}

async function forwardSignalToMT5(signalData) {
    if (!telegramConfig.mt5WebhookUrl) return false;
    
    try {
        // Convert signal to TelegramToMT5 EA format
        const mt5Signal = {
            action: signalData.action === 'OPEN' ? 'OPEN' : 'CLOSE',
            symbol: signalData.symbol,
            type: signalData.direction === 'BUY' ? 'BUY' : 'SELL',
            price: signalData.entry_price || signalData.exit_price,
            lot: signalData.lot_size,
            sl: signalData.stop_loss,
            tp: signalData.take_profit,
            comment: `TG-${signalData.trade_id}`,
            magic: 2026,
            timestamp: signalData.timestamp,
            source: 'FOREX-TELEGRAM-BRIDGE',
            // Additional fields for TelegramToMT5 EA
            ticket: 0,  // 0 for new orders
            slippage: 3,
            deviation: 10
        };
        
        const response = await fetch(telegramConfig.mt5WebhookUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(mt5Signal)
        });
        
        if (response.ok) {
            log(`üîó Signal forwarded to MT5: ${signalData.symbol}`, 'g');
            return true;
        } else {
            log(`‚ö†Ô∏è MT5 responded with error: ${response.status}`, 'y');
            return false;
        }
    } catch (err) {
        log(`‚ö†Ô∏è MT5 forward failed: ${err.message}`, 'y');
        return false;
    }
}

async function sendAlert(message, type = 'info') {
    if (!telegramConfig.alertEnabled || !telegramConfig.botToken || !telegramConfig.chatId) {
        return;
    }
    
    const emoji = type === 'info' ? '‚ÑπÔ∏è' : type === 'warning' ? '‚ö†Ô∏è' : 'üö®';
    
    try {
        await fetch(`https://api.telegram.org/bot${telegramConfig.botToken}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: telegramConfig.chatId,
                text: `${emoji} <b>FOREX ALERT</b>\n${message}`,
                parse_mode: 'HTML'
            })
        });
    } catch (err) {
        console.log('Alert send failed:', err);
    }
}

// =====================================================
// FOREX DATA FETCHING (Using Forex API)
// =====================================================
let forexData = {};
let economicCalendar = [];
let ecbLastUpdate = 0;

async function fetchForexPrices() {
    try {
        // Using free forex API (you can replace with your preferred provider)
        const response = await fetch('https://api.frankfurter.app/latest');
        const data = await response.json();
        
        // Convert to our format
        const baseRates = data.rates;
        forexData = {};
        
        // Create pairs from base rates
        SYM.forEach(sym => {
            const base = sym.s.substring(0, 3);
            const quote = sym.s.substring(4, 7);
            
            if (base === 'USD') {
                const rate = baseRates[quote];
                if (rate) {
                    const spread = sym.p * 2; // Simulated spread
                    forexData[sym.s] = {
                        bid: rate - spread/2,
                        ask: rate + spread/2,
                        mid: rate,
                        spread: spread / sym.p
                    };
                }
            } else if (quote === 'USD') {
                const rate = 1 / baseRates[base];
                if (rate) {
                    const spread = sym.p * 2;
                    forexData[sym.s] = {
                        bid: rate - spread/2,
                        ask: rate + spread/2,
                        mid: rate,
                        spread: spread / sym.p
                    };
                }
            }
        });
        
        // For XAUUSD, use different source
        if (!forexData['XAU/USD']) {
            try {
                const goldRes = await fetch('https://api.metalpriceapi.com/v1/latest?api_key=demo&base=XAU&currencies=USD');
                const goldData = await goldRes.json();
                if (goldData.rates && goldData.rates.USD) {
                    const rate = 1 / goldData.rates.USD;
                    const spread = 0.50;
                    forexData['XAU/USD'] = {
                        bid: rate - spread/2,
                        ask: rate + spread/2,
                        mid: rate,
                        spread: spread / 0.01
                    };
                }
            } catch (e) {}
        }
        
        document.getElementById('api').textContent = 'API:‚úì';
        document.getElementById('api').className = 'badge on';
        return true;
    } catch (e) {
        console.log('Forex API error:', e);
        document.getElementById('api').textContent = 'API:ERR';
        document.getElementById('api').className = 'badge off';
        
        // Fallback to simulated data
        simulateForexData();
        return true;
    }
}

async function fetchECBData() {
    const now = Date.now();
    if (now - ecbLastUpdate < C.ecbRefresh) return;
    
    try {
        // Fetch ECB interest rates (simulated - replace with real API)
        const response = await fetch('https://api.api-ninjas.com/v1/interestrate?country=Euro%20Area');
        const data = await response.json();
        if (data && data.length > 0) {
            ECB_BIAS['EUR'].rate = data[0].rate_pct;
            log('üè¶ ECB data updated', 'b');
        }
    } catch (e) {
        // Use fallback data
        console.log('ECB API error, using fallback data');
    }
    
    ecbLastUpdate = now;
}

async function fetchEconomicCalendar() {
    try {
        // Using Forex Factory calendar (simulated)
        const now = new Date();
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        // Simulated economic events
        economicCalendar = [
            {
                title: 'US Non-Farm Payrolls',
                country: 'USD',
                date: now.toISOString(),
                impact: 'high',
                forecast: '180K',
                previous: '199K'
            },
            {
                title: 'ECB Interest Rate Decision',
                country: 'EUR',
                date: now.toISOString(),
                impact: 'high',
                forecast: '4.0%',
                previous: '4.0%'
            },
            {
                title: 'BOE Inflation Report',
                country: 'GBP',
                date: now.toISOString(),
                impact: 'medium',
                forecast: '4.0%',
                previous: '4.2%'
            }
        ];
    } catch (e) {
        console.log('Economic calendar error:', e);
    }
}

function simulateForexData() {
    SYM.forEach(sym => {
        if (!forexData[sym.s]) {
            // Generate realistic price movements
            const basePrice = sym.mt5.includes('JPY') ? 
                (Math.random() * 50 + 100) : 
                (Math.random() * 0.5 + 1);
            
            const change = (Math.random() - 0.5) * sym.p * 10;
            const spread = sym.p * (1 + Math.random());
            
            forexData[sym.s] = {
                bid: basePrice + change - spread/2,
                ask: basePrice + change + spread/2,
                mid: basePrice + change,
                spread: spread / sym.p
            };
        }
    });
}

function isHighImpactNews(symbol) {
    const now = new Date();
    const baseCurrency = symbol.substring(0, 3);
    
    return economicCalendar.some(event => {
        if (!C.newsImpact.includes(event.impact)) return false;
        if (event.country !== baseCurrency) return false;
        
        const eventTime = new Date(event.date);
        const diff = Math.abs(now - eventTime);
        return diff < C.newsCooldown;
    });
}

// =====================================================
// TRADING ENGINE (Modified for Forex)
// =====================================================
let S = load() || fresh();
let prices = {}, history = {}, lastTrade = {}, logs = [], ticks = 0, dailyPnL = 0, dayStart = new Date().toDateString();

function fresh() {
    return {
        bal: C.start,
        pos: [],
        wins: 0,
        losses: 0,
        grossWin: 0,
        grossLoss: 0,
        eq: [C.start],
        streak: 0,
        best: C.start,
        peak: C.start,
        returns: []
    };
}

function load() {
    try {
        const data = JSON.parse(atob(location.hash.slice(1)));
        if (data.telegramConfig) {
            Object.assign(telegramConfig, data.telegramConfig);
        }
        return data;
    } catch (e) {
        return null;
    }
}

function save() {
    try {
        const data = {
            ...S,
            eq: S.eq.slice(-60),
            returns: S.returns.slice(-100),
            telegramConfig: telegramConfig
        };
        history.replaceState(null, '', '#' + btoa(JSON.stringify(data)));
    } catch (e) {}
}

function reset() {
    S = fresh();
    logs = [];
    prices = {};
    history = {};
    dailyPnL = 0;
    forexData = {};
    telegramConfig.signalsToday = 0;
    save();
    render();
    log('System reset', 'b');
}

function updateHistory(sym, price) {
    if (!history[sym]) history[sym] = [];
    history[sym].push(price);
    if (history[sym].length > 50) history[sym].shift();
}

function calcRSI(sym) {
    const h = history[sym];
    if (!h || h.length < C.rsiPeriod + 1) return 50;
    let gains = 0, losses = 0;
    for (let i = h.length - C.rsiPeriod; i < h.length; i++) {
        const diff = h[i] - h[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
    }
    if (losses === 0) return 100;
    const rs = gains / losses;
    return 100 - (100 / (1 + rs));
}

function calcMomentum(sym) {
    const h = history[sym];
    if (!h || h.length < 10) return 0;
    return ((h[h.length - 1] - h[h.length - 10]) / h[h.length - 10]) * 100;
}

function getECBBias(symbol) {
    const base = symbol.substring(0, 3);
    const quote = symbol.substring(4, 7);
    const baseBias = ECB_BIAS[base] ? ECB_BIAS[base].bias : 'neutral';
    const quoteBias = ECB_BIAS[quote] ? ECB_BIAS[quote].bias : 'neutral';
    
    if (baseBias === 'hawkish' && quoteBias === 'dovish') return 1; // Bullish
    if (baseBias === 'dovish' && quoteBias === 'hawkish') return -1; // Bearish
    return 0; // Neutral
}

function getSignal(sym) {
    const p = prices[sym];
    if (!p) return { score: 0, strength: 0, sig: null, rsi: 50, mom: 0, ecbBias: 0 };
    const rsi = calcRSI(sym);
    const mom = calcMomentum(sym);
    const ecbBias = getECBBias(sym);
    let score = 0, strength = 0;
    
    // ECB Bias Weight (40% of decision)
    score += ecbBias * 40;
    if (ecbBias !== 0) strength += 2;
    
    // RSI Analysis (30% of decision)
    if (rsi < 30 && ecbBias >= 0) { score += 20; strength++; }
    else if (rsi > 70 && ecbBias <= 0) { score -= 20; strength++; }
    else if (rsi < 40 && ecbBias > 0) { score += 10; strength++; }
    else if (rsi > 60 && ecbBias < 0) { score -= 10; strength++; }
    
    // Momentum Analysis (30% of decision)
    if (mom > 0.1 && ecbBias >= 0) { score += 15; strength++; }
    else if (mom < -0.1 && ecbBias <= 0) { score -= 15; strength++; }
    
    // Avoid trading during high-impact news
    if (isHighImpactNews(sym)) {
        score = 0;
        strength = 0;
    }
    
    if (p.spread > C.spreadMax) return { score, strength: 0, sig: null, rsi, mom, ecbBias };
    
    let sig = null;
    if (score >= 35 && strength >= C.minStrength) sig = 'BUY';
    else if (score <= -35 && strength >= C.minStrength) sig = 'SELL';
    
    return { score, strength, sig, rsi: Math.round(rsi), mom: mom.toFixed(2), ecbBias };
}

function updatePrices() {
    SYM.forEach(sym => {
        const fd = forexData[sym.s];
        if (!fd) return;
        const prevMid = prices[sym.s]?.mid || ((fd.bid + fd.ask) / 2);
        const mid = (fd.bid + fd.ask) / 2;
        updateHistory(sym.s, mid);
        const spreadPips = (fd.ask - fd.bid) / sym.p;
        const change = (mid - prevMid) / sym.p;
        prices[sym.s] = {
            bid: fd.bid,
            ask: fd.ask,
            mid: mid,
            change: change,
            spread: spreadPips,
            pip: sym.p,
            type: sym.t,
            pipFactor: sym.pipFactor
        };
    });
    ticks++;
}

function checkRiskShield() {
    const equity = S.bal + getUnrealized();
    const dd = (S.peak - equity) / S.peak * 100;
    const heat = (S.pos.length / C.maxPos) * 100;
    
    if (new Date().toDateString() !== dayStart) {
        dayStart = new Date().toDateString();
        dailyPnL = 0;
        telegramConfig.signalsToday = 0;
    }
    
    document.getElementById('dd').textContent = dd.toFixed(1) + '%';
    
    if (dd >= C.maxDD) {
        document.getElementById('shield').textContent = 'SHIELD:üõë';
        document.getElementById('shield').className = 'badge off';
        sendAlert(`üö® MAX DRAWDOWN REACHED: ${dd.toFixed(1)}%\nAll positions closed.`, 'danger');
        return false;
    }
    
    if (dailyPnL <= -C.dailyLossLimit) {
        document.getElementById('shield').textContent = 'SHIELD:üîí';
        document.getElementById('shield').className = 'badge warn';
        sendAlert(`üîí Daily loss limit reached: $${dailyPnL.toFixed(2)}\nTrading paused for today.`, 'warning');
        return false;
    }
    
    document.getElementById('shield').textContent = 'SHIELD:‚úì';
    document.getElementById('shield').className = 'badge on';
    return true;
}

function calcLotSize(sym) {
    const pair = SYM.find(s => s.s === sym);
    const volFactor = 1.0;
    const streakFactor = S.streak < -2 ? 0.5 : 1;
    const lot = Math.max(0.01, Math.min(0.1, C.baseLot * volFactor * streakFactor));
    document.getElementById('lotSize').textContent = lot.toFixed(2);
    return lot;
}

function getUnrealized() {
    let u = 0;
    S.pos.forEach(pos => {
        const p = prices[pos.sym];
        if (!p) return;
        const cur = pos.type === 'BUY' ? p.bid : p.ask;
        const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
        u += pips * pos.pipValue;
    });
    return u;
}

function hasCorrelatedPosition(sym) {
    const base = sym.substring(0, 3);
    const quote = sym.substring(4, 7);
    return S.pos.some(p => {
        const pBase = p.sym.substring(0, 3);
        const pQuote = p.sym.substring(4, 7);
        return pBase === base || pQuote === quote;
    });
}

function generateTradeId() {
    return 'FX-' + Date.now().toString(36).toUpperCase() + '-' + Math.random().toString(36).substring(2, 6).toUpperCase();
}

function trade() {
    if (!checkRiskShield()) return;
    const now = Date.now();
    
    SYM.forEach(sym => {
        const p = prices[sym.s];
        if (!p) return;
        if (lastTrade[sym.s] && now - lastTrade[sym.s] < C.cooldown) return;
        if (hasCorrelatedPosition(sym.s)) return;
        if (S.pos.length >= C.maxPos) return;
        if (isHighImpactNews(sym.s)) return; // Skip during news
        
        const { sig, strength, ecbBias } = getSignal(sym.s);
        if (sig) {
            const lot = calcLotSize(sym.s);
            const pipValue = lot * 10000 * sym.p;
            const isBuy = sig === 'BUY';
            const entry = isBuy ? p.ask : p.bid;
            const tradeId = generateTradeId();
            
            const newPos = {
                id: tradeId,
                sym: sym.s,
                type: sig,
                entry,
                tp: isBuy ? entry + C.tp * sym.p : entry - C.tp * sym.p,
                sl: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
                trail: null,
                pipValue,
                pip: sym.p,
                lot,
                strength,
                ecbBias,
                time: now
            };
            
            S.pos.push(newPos);
            
            // üîó FORWARD SIGNAL VIA TELEGRAM
            forwardSignalToTelegram({
                action: 'OPEN',
                trade_id: tradeId,
                symbol: sym.mt5,  // Use MT5 symbol format
                direction: sig,
                entry_price: entry,
                take_profit: newPos.tp,
                stop_loss: newPos.sl,
                lot_size: lot,
                signal_strength: strength,
                timestamp: new Date().toISOString()
            });
            
            lastTrade[sym.s] = now;
            
            const biasText = ecbBias > 0 ? 'ü¶Ö HAWKISH' : ecbBias < 0 ? 'üïäÔ∏è DOVISH' : '‚öñÔ∏è NEUTRAL';
            log(`${sig === 'BUY' ? 'üü¢' : 'üî¥'} ${sig} ${sym.s} @${entry.toFixed(5)} [${strength}‚òÖ] ${biasText}`, sig === 'BUY' ? 'g' : 'r');
            save();
        }
    });
    
    managePositions();
}

function managePositions() {
    const toClose = [];
    
    S.pos.forEach((pos, i) => {
        const p = prices[pos.sym];
        if (!p) return;
        
        const isBuy = pos.type === 'BUY';
        const cur = isBuy ? p.bid : p.ask;
        const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
        const pnl = pips * pos.pipValue;
        
        // Trailing Stop Logic
        if (pips >= C.trail) {
            const newTrail = isBuy ? cur - (2 * pos.pip) : cur + (2 * pos.pip);
            if (!pos.trail || (isBuy ? newTrail > pos.trail : newTrail < pos.trail)) {
                pos.trail = newTrail;
            }
        }
        
        // Check Exits
        let reason = null;
        if (isBuy) {
            if (cur >= pos.tp) reason = "TP";
            else if (cur <= pos.sl) reason = "SL";
            else if (pos.trail && cur <= pos.trail) reason = "TRAIL";
        } else {
            if (cur <= pos.tp) reason = "TP";
            else if (cur >= pos.sl) reason = "SL";
            else if (pos.trail && cur >= pos.trail) reason = "TRAIL";
        }
        
        if (reason) {
            toClose.push({ index: i, reason, exitPrice: cur, pips, pnl, pos });
        }
    });
    
    // Process Closures
    toClose.reverse().forEach(c => {
        const p = S.pos.splice(c.index, 1)[0];
        
        // Update Stats
        S.bal += c.pnl;
        dailyPnL += c.pnl;
        if (c.pnl > 0) {
            S.wins++;
            S.grossWin += c.pnl;
            S.streak = Math.max(0, S.streak + 1);
        } else {
            S.losses++;
            S.grossLoss += Math.abs(c.pnl);
            S.streak = Math.min(0, S.streak - 1);
        }
        
        if (S.bal > S.peak) S.peak = S.bal;
        S.returns.push(c.pnl);
        
        // üîó FORWARD CLOSE SIGNAL VIA TELEGRAM
        forwardSignalToTelegram({
            action: 'CLOSE',
            trade_id: p.id,
            symbol: p.sym,
            exit_reason: c.reason,
            exit_price: c.exitPrice,
            pnl_usd: c.pnl,
            pnl_pips: c.pips,
            duration_ms: Date.now() - p.time,
            timestamp: new Date().toISOString()
        });
        
        log(`üèÅ ${c.reason} ${p.sym}: ${c.pnl > 0 ? '+' : ''}$${c.pnl.toFixed(2)} (${c.pips.toFixed(1)} pips)`, c.pnl > 0 ? 'g' : 'r');
    });
    
    if (toClose.length > 0) {
        S.eq.push(S.bal);
        save();
    }
}

function render() {
    const equity = S.bal + getUnrealized();
    const pnl = equity - C.start;
    
    document.getElementById('equity').textContent = '$' + equity.toFixed(2);
    document.getElementById('equity').className = pnl >= 0 ? 'g' : 'r';
    document.getElementById('pnl').textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
    document.getElementById('pnlPct').textContent = (pnl >= 0 ? '+' : '') + (pnl / C.start * 100).toFixed(2) + '%';
    
    document.getElementById('trades').textContent = S.wins + S.losses;
    const wr = (S.wins + S.losses) > 0 ? (S.wins / (S.wins + S.losses) * 100) : 0;
    document.getElementById('winrate').textContent = wr.toFixed(1) + '%';
    document.getElementById('winrate').className = wr >= 50 ? 'g' : wr >= 40 ? 'y' : 'r';
    
    const pf = S.grossLoss > 0 ? (S.grossWin / S.grossLoss).toFixed(2) : '‚àû';
    document.getElementById('pf').textContent = pf;
    
    document.getElementById('openPos').textContent = S.pos.length + '/' + C.maxPos;
    document.getElementById('streak').textContent = (S.streak > 0 ? '+' : '') + S.streak;
    document.getElementById('streak').className = S.streak > 0 ? 'g' : S.streak < 0 ? 'r' : '';
    document.getElementById('best').textContent = '$' + S.best.toFixed(2);
    document.getElementById('avgWin').textContent = '$' + (S.wins > 0 ? (S.grossWin / S.wins).toFixed(2) : '0');
    document.getElementById('avgLoss').textContent = '$' + (S.losses > 0 ? (S.grossLoss / S.losses).toFixed(2) : '0');
    
    // Update Market Table
    let marketHTML = '';
    SYM.forEach(s => {
        const p = prices[s.s];
        if (!p) return;
        const sig = getSignal(s.s);
        
        // Find position P&L
        let posPnl = 0;
        const pos = S.pos.find(pos => pos.sym === s.s);
        if (pos) {
            const cur = pos.type === 'BUY' ? p.bid : p.ask;
            const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
            posPnl = pips * pos.pipValue;
        }
        
        const ecbBiasValue = getECBBias(s.s);
        const ecbBiasIcon = ecbBiasValue > 0 ? 'ü¶Ö' : ecbBiasValue < 0 ? 'üïäÔ∏è' : '‚öñÔ∏è';
        
        marketHTML += `<tr>
            <td><b>${s.s}</b></td>
            <td>${p.bid.toFixed(s.mt5.includes('JPY') || s.s.includes('XAU') ? 2 : 5)}</td>
            <td>${p.ask.toFixed(s.mt5.includes('JPY') || s.s.includes('XAU') ? 2 : 5)}</td>
            <td class="${p.change >= 0 ? 'g' : 'r'}">${(p.change / s.p).toFixed(1)}p</td>
            <td class="${sig.rsi < 30 ? 'g' : sig.rsi > 70 ? 'r' : ''}">${sig.rsi}</td>
            <td class="${sig.mom > 0 ? 'g' : sig.mom < 0 ? 'r' : ''}">${sig.mom}</td>
            <td>${ecbBiasIcon}</td>
            <td class="${sig.sig === 'BUY' ? 'g' : sig.sig === 'SELL' ? 'r' : 'dim'}">${sig.sig || '--'}</td>
            <td class="${posPnl >= 0 ? 'g' : 'r'}">${posPnl >= 0 ? '+' : ''}$${posPnl.toFixed(2)}</td>
        </tr>`;
    });
    document.getElementById('market').innerHTML = marketHTML;
    
    // Update Positions
    if (S.pos.length === 0) {
        document.getElementById('positions').innerHTML = '<span class="dim">No open positions</span>';
    } else {
        let positionsHTML = '';
        S.pos.forEach(pos => {
            const p = prices[pos.sym];
            if (!p) return;
            const cur = pos.type === 'BUY' ? p.bid : p.ask;
            const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
            const pnl = pips * pos.pipValue;
            positionsHTML += `<div class="log" style="border-left:2px solid ${pnl >= 0 ? 'var(--g)' : 'var(--r)'}">
                ${pos.type === 'BUY' ? 'üü¢' : 'üî¥'} ${pos.sym} ${pos.type} @${pos.entry.toFixed(5)}
                <span class="${pnl >= 0 ? 'g' : 'r'}">${pips >= 0 ? '+' : ''}${pips.toFixed(1)}p ($${pnl.toFixed(2)})</span>
            </div>`;
        });
        document.getElementById('positions').innerHTML = positionsHTML;
    }
    
    // Update time
    document.getElementById('time').textContent = new Date().toLocaleTimeString();
    
    // Update equity chart
    S.eq.push(equity);
    if (S.eq.length > 60) S.eq.shift();
    const min = Math.min(...S.eq) * 0.98;
    const max = Math.max(...S.eq) * 1.02;
    const range = max - min || 1;
    
    let chartHTML = '';
    S.eq.forEach((v, i) => {
        const h = Math.max(4, ((v - min) / range) * 100);
        const c = v >= C.start ? 'var(--g)' : 'var(--r)';
        const o = 0.3 + (i / S.eq.length) * 0.7;
        chartHTML += `<div style="height:${h}%;background:${c};opacity:${o}"></div>`;
    });
    document.getElementById('chart').innerHTML = chartHTML;
}

function log(msg, cls) {
    const entry = { msg, cls, t: Date.now() };
    logs.unshift(entry);
    if (logs.length > 20) logs.pop();
    
    const logEl = document.getElementById('log');
    const div = document.createElement('div');
    div.className = 'log ' + (cls || '');
    div.innerHTML = `<span class="dim">[${new Date(entry.t).toLocaleTimeString()}]</span> ${msg}`;
    logEl.prepend(div);
    if (logEl.children.length > 50) logEl.lastChild.remove();
}

// =====================================================
// INITIALIZATION
// =====================================================
async function init() {
    loadTelegramConfig();
    log('üöÄ FOREX ULTRA 2026 - Telegram Bridge Starting...', 'b');
    log('üì° Connecting to Forex Data Sources...', 'b');
    log('üè¶ Loading ECB Interest Rate Data...', 'b');
    
    // Initial data fetch
    await fetchECBData();
    await fetchEconomicCalendar();
    const ok = await fetchForexPrices();
    
    if (ok) {
        log('‚úÖ Forex data connected', 'g');
        log('üè¶ ECB bias data loaded', 'g');
        updatePrices();
        render();
        
        // Send startup alert
        if (telegramConfig.botToken && telegramConfig.chatId) {
            sendAlert('üöÄ FOREX ULTRA 2026 Telegram Bridge Started\nSystem is now monitoring 28 forex pairs with ECB bias analysis.');
        }
        
        // Start trading engine
        setInterval(async () => {
            await fetchForexPrices();
            updatePrices();
            trade();
            render();
        }, 3000);
        
        // Update ECB data periodically
        setInterval(fetchECBData, C.ecbRefresh);
        
        // Update economic calendar
        setInterval(fetchEconomicCalendar, 600000); // 10 minutes
        
        // Update status
        document.getElementById('status').textContent = 'üü¢ LIVE';
        document.getElementById('status').className = 'badge on';
        
    } else {
        log('‚ùå Failed to connect to forex data', 'r');
        document.getElementById('status').textContent = 'üî¥ ERROR';
        document.getElementById('status').className = 'badge off';
    }
}

// Start the system
init();
</script>
</body>
</html>
