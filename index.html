<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>HFT Ultra 2026 - Telegram Bridge</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0e14;--card:#121820;--border:#1a2030;--txt:#c8d0dc;--dim:#5a6270;--g:#0f6;--r:#f44;--b:#0af;--y:#fc0}
html.light{--bg:#f4f6f8;--card:#fff;--border:#dde;--txt:#1a1a2e;--dim:#888}
body{background:var(--bg);color:var(--txt);font:11px/1.4 monospace;padding:8px;min-height:100vh}
.g{color:var(--g)}.r{color:var(--r)}.b{color:var(--b)}.y{color:var(--y)}.dim{color:var(--dim)}
.card{background:var(--card);border:1px solid var(--border);border-radius:4px;padding:8px;margin-bottom:8px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.col{flex:1;min-width:120px}
.grid{display:grid;gap:4px}
.g2{grid-template-columns:repeat(2,1fr)}.g3{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(4,1fr)}.g6{grid-template-columns:repeat(6,1fr)}
.stat{background:var(--bg);padding:6px;border-radius:3px;text-align:center}
.stat small{display:block;font-size:9px;color:var(--dim);margin-bottom:2px}
.stat b{font-size:13px}
h1{font-size:14px;margin-bottom:4px}
table{width:100%;border-collapse:collapse;font-size:10px}
th,td{padding:4px;text-align:right}
th{color:var(--dim);font-weight:400;border-bottom:1px solid var(--border)}
td:first-child,th:first-child{text-align:left}
tr:hover{background:rgba(255,255,255,.02)}
.scroll{max-height:200px;overflow-y:auto}
.bar{height:40px;display:flex;align-items:end;gap:1px}
.bar div{flex:1;min-width:2px;border-radius:1px 1px 0 0}
.log{font-size:9px;padding:2px 4px;margin:1px 0;border-radius:2px;background:var(--bg)}
button{background:var(--card);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;cursor:pointer;font:inherit}
button:hover{background:var(--border)}
.pulse{animation:p 1.5s infinite}@keyframes p{50%{opacity:.5}}
.badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px}
.badge.on{background:#0f62;color:var(--g)}.badge.off{background:#f442;color:var(--r)}.badge.warn{background:#fc02;color:var(--y)}
input[type="text"]{background:var(--bg);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;font:inherit;width:100%;font-size:16px}
input[type="text"]:focus{outline:none;border-color:var(--b)}
.webhook-status{font-size:9px;margin-top:4px}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:400px;width:90%}
.modal h3{margin-bottom:12px;font-size:14px}
.modal-buttons{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
@media(max-width:600px){.g6{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>
<div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
<div>
<h1>‚ö° HFT ULTRA <span class="dim">2026</span> <span class="y">[TELEGRAM BRIDGE]</span></h1>
<small class="dim">29 PAIRS ‚Ä¢ REAL BINANCE DATA ‚Ä¢ TELEGRAM ‚Üí MT5 BRIDGE ‚Ä¢ AI SIGNALS</small>
</div>
<div class="row" style="gap:4px">
<span id="status" class="badge pulse">INIT</span>
<span id="api" class="badge dim">API:--</span>
<span id="telegramStatus" class="badge dim">TG:--</span>
<span id="shield" class="badge">SHIELD:--</span>
<button onclick="showTelegramConfig()">‚öôÔ∏è</button>
<button onclick="reset()">‚ü≤</button>
</div>
</div>

<div class="grid g6" style="margin-bottom:8px">
<div class="stat"><small>üí∞ EQUITY</small><b id="equity" class="g">$100.00</b><div id="pnlPct" style="font-size:9px">+0.00%</div></div>
<div class="stat"><small>P&L</small><b id="pnl">$0.00</b></div>
<div class="stat"><small>TRADES</small><b id="trades" class="b">0</b></div>
<div class="stat"><small>WIN%</small><b id="winrate" class="y">0%</b></div>
<div class="stat"><small>PROFIT F.</small><b id="pf" class="g">0.00</b></div>
<div class="stat"><small>OPEN</small><b id="openPos" class="b">0/6</b></div>
<div class="stat"><small>STREAK</small><b id="streak">0</b></div>
<div class="stat"><small>BEST</small><b id="best" class="g">$100</b></div>
<div class="stat"><small>DD</small><b id="dd" class="r">0%</b></div>
<div class="stat"><small>AVG WIN</small><b id="avgWin" class="g">$0</b></div>
<div class="stat"><small>AVG LOSS</small><b id="avgLoss" class="r">$0</b></div>
<div class="stat"><small>SIGNALS SENT</small><b id="signalsSent" class="b">0</b></div>
</div>

<div class="row">
<div class="col" style="flex:3">
<div class="card">
<div class="row" style="justify-content:space-between;margin-bottom:4px">
<b class="b">üìä MARKET</b>
<span id="time" class="dim">--:--:--</span>
</div>
<div class="scroll"><table><thead><tr><th>SYM</th><th>BID</th><th>ASK</th><th>Œî</th><th>RSI</th><th>MOM</th><th>SIG</th><th>P&L</th></tr></thead><tbody id="market"></tbody></table></div>
</div>
</div>
<div class="col">
<div class="card">
<b>üìà POSITIONS</b>
<div id="positions" class="scroll" style="margin-top:4px"><span class="dim">Scanning...</span></div>
</div>
<div class="card">
<b>‚ö° LOG</b>
<div id="log" class="scroll" style="margin-top:4px"><span class="dim">Starting...</span></div>
</div>
</div>
</div>

<div class="row">
<div class="col">
<div class="card"><b>üíπ EQUITY</b><div class="bar" id="chart"></div></div>
</div>
<div class="col">
<div class="card">
<b>ü§ñ TELEGRAM BRIDGE</b>
<div class="grid g3" style="margin-top:6px;font-size:9px;text-align:center">
<div class="stat"><small>BOT STATUS</small><span id="botStatus" class="y">OFFLINE</span></div>
<div class="stat"><small>SIGNALS TODAY</small><span id="signalsToday">0</span></div>
<div class="stat"><small>CHAT ID</small><span id="chatIdDisplay">--</span></div>
<div class="stat"><small>LAST SIGNAL</small><span id="lastSignalTime">--:--</span></div>
<div class="stat"><small>SUCCESS RATE</small><span id="successRate" class="g">100%</span></div>
<div class="stat"><small>LOT SIZE</small><span id="lotSize" class="b">0.01</span></div>
</div>
</div>
</div>
</div>

<!-- Telegram Config Modal -->
<div id="telegramModal" class="modal-overlay" style="display:none">
<div class="modal">
<h3>ü§ñ TELEGRAM BRIDGE CONFIGURATION</h3>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">1. Telegram Bot Token</label>
<input type="text" id="telegramToken" placeholder="1234567890:ABCdefGHIjklMNopQRstuVWXyz">
<small class="dim">Get from @BotFather on Telegram</small>
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">2. Your Chat ID</label>
<input type="text" id="telegramChatId" placeholder="123456789">
<small class="dim">Send /start to @userinfobot to get your ID</small>
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">3. MT5 EA Webhook URL</label>
<input type="text" id="mt5WebhookUrl" placeholder="http://192.168.1.100:24843/webhook">
<small class="dim">Your MT5 Expert Advisor endpoint</small>
</div>
<div class="grid g2" style="margin-bottom:12px">
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgSignalEnabled" checked> Send Trading Signals
</label>
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgAlertEnabled" checked> Send Alerts
</label>
</div>
<div class="webhook-status" id="telegramTestResult"></div>
<div class="modal-buttons">
<button onclick="testTelegramConnection()">üß™ Test Telegram</button>
<button onclick="testMT5Connection()">üîó Test MT5</button>
<button onclick="saveTelegramConfig()">üíæ Save</button>
<button onclick="closeTelegramModal()">‚úï Close</button>
</div>
</div>
</div>

<script>
// =====================================================
// TELEGRAM BRIDGE CONFIGURATION
// =====================================================
const telegramConfig = {
    botToken: '',           // From @BotFather
    chatId: '',             // Your chat ID
    mt5WebhookUrl: '',      // Your MT5 EA endpoint
    signalEnabled: true,    // Send trading signals
    alertEnabled: true,     // Send alerts
    signalsSent: 0,
    signalsToday: 0,
    lastSignalTime: null,
    successCount: 0,
    errorCount: 0
};

// =====================================================
// CRYPTO INSTRUMENTS (29 pairs)
// =====================================================
const SYM=[
    {s:'BTC/USDT',b:'BTCUSDT',p:.01,t:'major',mt5:'BTCUSD'},
    {s:'ETH/USDT',b:'ETHUSDT',p:.01,t:'major',mt5:'ETHUSD'},
    {s:'BNB/USDT',b:'BNBUSDT',p:.01,t:'major',mt5:'BNBUSD'},
    {s:'XRP/USDT',b:'XRPUSDT',p:.0001,t:'alt',mt5:'XRPUSD'},
    {s:'SOL/USDT',b:'SOLUSDT',p:.01,t:'major',mt5:'SOLUSD'},
    {s:'DOGE/USDT',b:'DOGEUSDT',p:.00001,t:'alt',mt5:'DOGEUSD'},
    {s:'ADA/USDT',b:'ADAUSDT',p:.0001,t:'alt',mt5:'ADAUSD'},
    {s:'AVAX/USDT',b:'AVAXUSDT',p:.01,t:'alt',mt5:'AVAXUSD'},
    {s:'LINK/USDT',b:'LINKUSDT',p:.001,t:'alt',mt5:'LINKUSD'},
    {s:'DOT/USDT',b:'DOTUSDT',p:.001,t:'alt',mt5:'DOTUSD'},
    {s:'MATIC/USDT',b:'MATICUSDT',p:.0001,t:'alt',mt5:'MATICUSD'},
    {s:'SHIB/USDT',b:'SHIBUSDT',p:.00000001,t:'meme',mt5:'SHIBUSD'},
    {s:'LTC/USDT',b:'LTCUSDT',p:.01,t:'major',mt5:'LTCUSD'},
    {s:'TRX/USDT',b:'TRXUSDT',p:.0001,t:'alt',mt5:'TRXUSD'},
    {s:'ATOM/USDT',b:'ATOMUSDT',p:.001,t:'alt',mt5:'ATOMUSD'},
    {s:'UNI/USDT',b:'UNIUSDT',p:.001,t:'defi',mt5:'UNIUSD'},
    {s:'ETC/USDT',b:'ETCUSDT',p:.01,t:'alt',mt5:'ETCUSD'},
    {s:'XLM/USDT',b:'XLMUSDT',p:.0001,t:'alt',mt5:'XLMUSD'},
    {s:'NEAR/USDT',b:'NEARUSDT',p:.001,t:'alt',mt5:'NEARUSD'},
    {s:'APT/USDT',b:'APTUSDT',p:.01,t:'alt',mt5:'APTUSD'},
    {s:'FIL/USDT',b:'FILUSDT',p:.001,t:'alt',mt5:'FILUSD'},
    {s:'ARB/USDT',b:'ARBUSDT',p:.0001,t:'l2',mt5:'ARBUSD'},
    {s:'OP/USDT',b:'OPUSDT',p:.0001,t:'l2',mt5:'OPUSD'},
    {s:'INJ/USDT',b:'INJUSDT',p:.01,t:'defi',mt5:'INJUSD'},
    {s:'SUI/USDT',b:'SUIUSDT',p:.0001,t:'alt',mt5:'SUIUSD'},
    {s:'PEPE/USDT',b:'PEPEUSDT',p:.000000001,t:'meme',mt5:'PEPEUSD'},
    {s:'WIF/USDT',b:'WIFUSDT',p:.0001,t:'meme',mt5:'WIFUSD'},
    {s:'RENDER/USDT',b:'RENDERUSDT',p:.001,t:'ai',mt5:'RENDERUSD'},
    {s:'FET/USDT',b:'FETUSDT',p:.0001,t:'ai',mt5:'FETUSD'}
];

// =====================================================
// TRADING CONFIGURATION
// =====================================================
const C={
    start:100,
    baseLot:.01,
    tp:15,           // 15 pip TP (3:1 RR)
    sl:5,            // 5 pip SL tight
    trail:6,         // Trail after 6 pips
    maxPos:6,
    maxDD:5,
    dailyLossLimit:3,
    cooldown:3000,
    rsiPeriod:14,
    minRSI:25,
    maxRSI:75,
    minStrength:3,
    spreadMax:2,
    corrThreshold:.7
};

// =====================================================
// TELEGRAM BRIDGE FUNCTIONS
// =====================================================
function loadTelegramConfig() {
    try {
        const hash = location.hash.slice(1);
        if (hash) {
            const data = JSON.parse(atob(hash));
            if (data.telegramConfig) {
                Object.assign(telegramConfig, data.telegramConfig);
            }
        }
    } catch (e) {
        console.log('No Telegram config found');
    }
    updateTelegramUI();
}

function saveTelegramConfig() {
    telegramConfig.botToken = document.getElementById('telegramToken').value.trim();
    telegramConfig.chatId = document.getElementById('telegramChatId').value.trim();
    telegramConfig.mt5WebhookUrl = document.getElementById('mt5WebhookUrl').value.trim();
    telegramConfig.signalEnabled = document.getElementById('tgSignalEnabled').checked;
    telegramConfig.alertEnabled = document.getElementById('tgAlertEnabled').checked;
    
    save(); // Save to URL hash
    updateTelegramUI();
    closeTelegramModal();
    log('ü§ñ Telegram config saved', 'b');
}

function showTelegramConfig() {
    document.getElementById('telegramToken').value = telegramConfig.botToken;
    document.getElementById('telegramChatId').value = telegramConfig.chatId;
    document.getElementById('mt5WebhookUrl').value = telegramConfig.mt5WebhookUrl;
    document.getElementById('tgSignalEnabled').checked = telegramConfig.signalEnabled;
    document.getElementById('tgAlertEnabled').checked = telegramConfig.alertEnabled;
    document.getElementById('telegramModal').style.display = 'flex';
}

function closeTelegramModal() {
    document.getElementById('telegramModal').style.display = 'none';
}

async function testTelegramConnection() {
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    const resultEl = document.getElementById('telegramTestResult');
    
    if (!token || !chatId) {
        resultEl.innerHTML = '<span class="r">‚ùå Enter Token & Chat ID</span>';
        return;
    }
    
    resultEl.innerHTML = '<span class="y">üîÑ Testing Telegram connection...</span>';
    
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
        const data = await response.json();
        
        if (data.ok) {
            resultEl.innerHTML = `<span class="g">‚úÖ Bot connected: ${data.result.username}</span>`;
            
            // Send test message
            setTimeout(async () => {
                try {
                    await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            chat_id: chatId,
                            text: '‚úÖ HFT ULTRA 2026 Telegram Bridge Connected!\nSystem ready to forward signals to MT5.'
                        })
                    });
                    log('‚úÖ Telegram test successful', 'g');
                } catch (msgErr) {
                    log(`‚ö†Ô∏è Could not send test message: ${msgErr.message}`, 'y');
                }
            }, 500);
        } else {
            resultEl.innerHTML = `<span class="r">‚ùå Invalid bot token</span>`;
        }
    } catch (err) {
        resultEl.innerHTML = `<span class="r">‚ùå Connection failed: ${err.message}</span>`;
    }
}

async function testMT5Connection() {
    const mt5Url = document.getElementById('mt5WebhookUrl').value.trim();
    const resultEl = document.getElementById('telegramTestResult');
    
    if (!mt5Url) {
        resultEl.innerHTML = '<span class="r">‚ùå Enter MT5 Webhook URL</span>';
        return;
    }
    
    resultEl.innerHTML = '<span class="y">üîÑ Testing MT5 connection...</span>';
    
    const testSignal = {
        action: 'TEST',
        symbol: 'BTCUSD',
        type: 'BUY',
        price: 50000,
        lot: 0.01,
        tp: 50150,
        sl: 49950,
        strength: 5,
        timestamp: new Date().toISOString(),
        source: 'HFT-TELEGRAM-BRIDGE-TEST'
    };
    
    try {
        const response = await fetch(mt5Url, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testSignal),
            mode: 'no-cors'
        });
        
        resultEl.innerHTML = '<span class="g">‚úÖ MT5 connection test sent (no-cors mode)</span>';
        log('‚úÖ MT5 test signal sent', 'g');
    } catch (err) {
        resultEl.innerHTML = `<span class="r">‚ùå MT5 connection failed</span>`;
        log(`‚ö†Ô∏è MT5 test failed: ${err.message}`, 'y');
    }
}

function updateTelegramUI() {
    const el = document.getElementById('telegramStatus');
    if (telegramConfig.botToken && telegramConfig.chatId) {
        el.textContent = 'TG:‚úì';
        el.className = 'badge on';
        document.getElementById('botStatus').textContent = 'ONLINE';
        document.getElementById('botStatus').className = 'g';
        document.getElementById('chatIdDisplay').textContent = telegramConfig.chatId.substring(0, 6) + '...';
    } else {
        el.textContent = 'TG:OFF';
        el.className = 'badge dim';
        document.getElementById('botStatus').textContent = 'OFFLINE';
        document.getElementById('botStatus').className = 'r';
    }
    
    document.getElementById('signalsSent').textContent = telegramConfig.signalsSent;
    document.getElementById('signalsToday').textContent = telegramConfig.signalsToday;
    document.getElementById('lastSignalTime').textContent = telegramConfig.lastSignalTime ? 
        telegramConfig.lastSignalTime.substring(11, 16) : '--:--';
    
    const total = telegramConfig.successCount + telegramConfig.errorCount;
    document.getElementById('successRate').textContent = total > 0 ? 
        Math.round((telegramConfig.successCount / total) * 100) + '%' : '100%';
}

// =====================================================
// SIGNAL FORWARDING SYSTEM
// =====================================================
async function forwardSignalToTelegram(signalData) {
    if (!telegramConfig.signalEnabled || !telegramConfig.botToken || !telegramConfig.chatId) {
        return false;
    }
    
    const signalType = signalData.action === 'OPEN' ? 'TRADE_SIGNAL' : 'TRADE_CLOSE';
    
    // Format message for Telegram
    let message = '';
    if (signalData.action === 'OPEN') {
        message = `üöÄ <b>${signalData.type} ${signalData.symbol}</b>\n`;
        message += `üí∞ Entry: <code>${signalData.entry_price.toFixed(5)}</code>\n`;
        message += `üéØ TP: <code>${signalData.take_profit.toFixed(5)}</code> (${C.tp} pips)\n`;
        message += `üõë SL: <code>${signalData.stop_loss.toFixed(5)}</code> (${C.sl} pips)\n`;
        message += `üìä Lot: <code>${signalData.lot_size}</code>\n`;
        message += `‚ö° Strength: ${signalData.signal_strength}/5\n`;
        message += `üÜî ${signalData.trade_id}\n`;
        message += `üïí ${new Date(signalData.timestamp).toLocaleTimeString()}`;
    } else {
        message = `üèÅ <b>${signalData.symbol} CLOSED</b>\n`;
        message += `üìä Result: <b>${signalData.exit_reason}</b>\n`;
        message += `üí∞ P&L: <code>$${signalData.pnl_usd.toFixed(2)}</code>\n`;
        message += `üìà Pips: <code>${signalData.pnl_pips.toFixed(1)}</code>\n`;
        message += `‚è±Ô∏è Duration: ${Math.round(signalData.duration_ms / 1000)}s\n`;
        message += `üÜî ${signalData.trade_id}\n`;
        message += `üïí ${new Date(signalData.timestamp).toLocaleTimeString()}`;
    }
    
    try {
        // Send to Telegram
        const tgResponse = await fetch(`https://api.telegram.org/bot${telegramConfig.botToken}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: telegramConfig.chatId,
                text: message,
                parse_mode: 'HTML',
                disable_web_page_preview: true
            })
        });
        
        if (tgResponse.ok) {
            telegramConfig.signalsSent++;
            telegramConfig.signalsToday++;
            telegramConfig.lastSignalTime = new Date().toISOString();
            telegramConfig.successCount++;
            
            // Update UI
            updateTelegramUI();
            
            log(`üì± Telegram signal sent: ${signalData.symbol}`, 'b');
            
            // Forward to MT5 if URL is set
            if (telegramConfig.mt5WebhookUrl) {
                setTimeout(() => forwardSignalToMT5(signalData), 100);
            }
            
            return true;
        }
    } catch (err) {
        telegramConfig.errorCount++;
        log(`‚ö†Ô∏è Telegram error: ${err.message}`, 'y');
    }
    
    return false;
}

async function forwardSignalToMT5(signalData) {
    if (!telegramConfig.mt5WebhookUrl) return false;
    
    try {
        // Convert signal to MT5 format
        const mt5Signal = {
            action: signalData.action,
            symbol: signalData.symbol.replace('/', '').replace('USDT', 'USD'),
            type: signalData.direction === 'BUY' ? 0 : 1,
            price: signalData.entry_price || signalData.exit_price,
            volume: signalData.lot_size,
            sl: signalData.stop_loss,
            tp: signalData.take_profit,
            comment: `TG-${signalData.trade_id}`,
            magic: 2026,
            timestamp: signalData.timestamp,
            source: 'HFT-TELEGRAM-BRIDGE'
        };
        
        await fetch(telegramConfig.mt5WebhookUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(mt5Signal),
            mode: 'no-cors'
        });
        
        log(`üîó Signal forwarded to MT5: ${signalData.symbol}`, 'g');
        return true;
    } catch (err) {
        log(`‚ö†Ô∏è MT5 forward failed: ${err.message}`, 'y');
        return false;
    }
}

async function sendAlert(message, type = 'info') {
    if (!telegramConfig.alertEnabled || !telegramConfig.botToken || !telegramConfig.chatId) {
        return;
    }
    
    const emoji = type === 'info' ? '‚ÑπÔ∏è' : type === 'warning' ? '‚ö†Ô∏è' : 'üö®';
    
    try {
        await fetch(`https://api.telegram.org/bot${telegramConfig.botToken}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: telegramConfig.chatId,
                text: `${emoji} <b>HFT ALERT</b>\n${message}`,
                parse_mode: 'HTML'
            })
        });
    } catch (err) {
        console.log('Alert send failed:', err);
    }
}

// =====================================================
// ORIGINAL TRADING ENGINE (MODIFIED FOR TELEGRAM)
// =====================================================
let S = load() || fresh();
let prices = {}, history = {}, lastTrade = {}, logs = [], ticks = 0, dailyPnL = 0, dayStart = new Date().toDateString();
let binanceData = {};

function fresh() {
    return {
        bal: C.start,
        pos: [],
        wins: 0,
        losses: 0,
        grossWin: 0,
        grossLoss: 0,
        eq: [C.start],
        streak: 0,
        best: C.start,
        peak: C.start,
        returns: []
    };
}

function load() {
    try {
        const data = JSON.parse(atob(location.hash.slice(1)));
        if (data.telegramConfig) {
            Object.assign(telegramConfig, data.telegramConfig);
        }
        return data;
    } catch (e) {
        return null;
    }
}

function save() {
    try {
        const data = {
            ...S,
            eq: S.eq.slice(-60),
            returns: S.returns.slice(-100),
            telegramConfig: telegramConfig
        };
        history.replaceState(null, '', '#' + btoa(JSON.stringify(data)));
    } catch (e) {}
}

function reset() {
    S = fresh();
    logs = [];
    prices = {};
    history = {};
    dailyPnL = 0;
    binanceData = {};
    telegramConfig.signalsToday = 0;
    save();
    render();
    log('System reset', 'b');
}

async function fetchBinancePrices() {
    try {
        const symbols = SYM.map(s => s.b);
        const r = await fetch('https://api.binance.com/api/v3/ticker/bookTicker');
        const data = await r.json();
        data.forEach(t => {
            binanceData[t.symbol] = {
                bid: parseFloat(t.bidPrice),
                ask: parseFloat(t.askPrice)
            };
        });
        
        const r2 = await fetch('https://api.binance.com/api/v3/ticker/24hr');
        const data24 = await r2.json();
        data24.forEach(t => {
            if (binanceData[t.symbol]) {
                binanceData[t.symbol].change24 = parseFloat(t.priceChangePercent);
            }
        });
        
        document.getElementById('api').textContent = 'API:‚úì';
        document.getElementById('api').className = 'badge on';
        return true;
    } catch (e) {
        console.log('Binance API error:', e);
        document.getElementById('api').textContent = 'API:ERR';
        document.getElementById('api').className = 'badge off';
        return false;
    }
}

function updateHistory(sym, price) {
    if (!history[sym]) history[sym] = [];
    history[sym].push(price);
    if (history[sym].length > 50) history[sym].shift();
}

function calcRSI(sym) {
    const h = history[sym];
    if (!h || h.length < C.rsiPeriod + 1) return 50;
    let gains = 0, losses = 0;
    for (let i = h.length - C.rsiPeriod; i < h.length; i++) {
        const diff = h[i] - h[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
    }
    if (losses === 0) return 100;
    const rs = gains / losses;
    return 100 - (100 / (1 + rs));
}

function calcMomentum(sym) {
    const h = history[sym];
    if (!h || h.length < 10) return 0;
    return ((h[h.length - 1] - h[h.length - 10]) / h[h.length - 10]) * 100;
}

function calcVolatility(sym) {
    const h = history[sym];
    if (!h || h.length < 10) return 1;
    let sum = 0;
    for (let i = 1; i < Math.min(h.length, 10); i++) sum += Math.abs(h[i] - h[i - 1]);
    return sum / 9;
}

function getCorrelatedPairs(sym) {
    const corr = {
        'BTC/USDT': ['ETH/USDT', 'SOL/USDT'],
        'ETH/USDT': ['BTC/USDT', 'SOL/USDT'],
        'SOL/USDT': ['ETH/USDT', 'AVAX/USDT'],
        'DOGE/USDT': ['SHIB/USDT', 'PEPE/USDT'],
        'SHIB/USDT': ['DOGE/USDT', 'PEPE/USDT'],
        'ARB/USDT': ['OP/USDT'],
        'OP/USDT': ['ARB/USDT'],
        'RENDER/USDT': ['FET/USDT'],
        'FET/USDT': ['RENDER/USDT']
    };
    return corr[sym] || [];
}

function updatePrices() {
    SYM.forEach(sym => {
        const bd = binanceData[sym.b];
        if (!bd) return;
        const prevMid = prices[sym.s]?.mid || ((bd.bid + bd.ask) / 2);
        const mid = (bd.bid + bd.ask) / 2;
        updateHistory(sym.s, mid);
        const spreadPips = (bd.ask - bd.bid) / sym.p;
        const change = (mid - prevMid) / sym.p;
        prices[sym.s] = {
            bid: bd.bid,
            ask: bd.ask,
            mid: mid,
            change: change,
            spread: spreadPips,
            pip: sym.p,
            type: sym.t,
            change24: bd.change24 || 0
        };
    });
    ticks++;
}

function getSignal(sym) {
    const p = prices[sym];
    if (!p) return { score: 0, strength: 0, sig: null, rsi: 50, mom: 0 };
    const rsi = calcRSI(sym);
    const mom = calcMomentum(sym);
    const vol = calcVolatility(sym);
    let score = 0, strength = 0;
    
    if (rsi < C.minRSI) { score += 20; strength++; }
    else if (rsi > C.maxRSI) { score -= 20; strength++; }
    else if (rsi < 40) { score += 10; }
    else if (rsi > 60) { score -= 10; }
    
    if (mom > 0.05 && rsi < 50) { score += 15; strength++; }
    else if (mom < -0.05 && rsi > 50) { score -= 15; strength++; }
    
    const h = history[sym];
    if (h && h.length >= 20) {
        const ma20 = h.slice(-20).reduce((a, b) => a + b, 0) / 20;
        if (p.mid > ma20 && mom > 0) { score += 12; strength++; }
        else if (p.mid < ma20 && mom < 0) { score -= 12; strength++; }
    }
    
    if (vol < p.mid * 0.001) { strength++; }
    
    if (p.change24) {
        if (p.change24 > 2 && rsi < 60) { score += 10; strength++; }
        else if (p.change24 < -2 && rsi > 40) { score -= 10; strength++; }
    }
    
    if (sym !== 'BTC/USDT') {
        const btc = prices['BTC/USDT'];
        if (btc) {
            if (btc.change > 0 && p.change > 0) { strength++; }
            else if (btc.change < 0 && p.change < 0) { strength++; }
        }
    }
    
    const corr = getCorrelatedPairs(sym);
    corr.forEach(c => {
        const cp = prices[c];
        if (cp) {
            if ((score > 0 && cp.change > 0) || (score < 0 && cp.change < 0)) strength++;
        }
    });
    
    if (p.spread > C.spreadMax) return { score, strength: 0, sig: null, rsi, mom };
    
    let sig = null;
    if (score >= 25 && strength >= C.minStrength) sig = 'BUY';
    else if (score <= -25 && strength >= C.minStrength) sig = 'SELL';
    
    return { score, strength, sig, rsi: Math.round(rsi), mom: mom.toFixed(2) };
}

function checkRiskShield() {
    const equity = S.bal + getUnrealized();
    const dd = (S.peak - equity) / S.peak * 100;
    const heat = (S.pos.length / C.maxPos) * 100;
    
    if (new Date().toDateString() !== dayStart) {
        dayStart = new Date().toDateString();
        dailyPnL = 0;
        telegramConfig.signalsToday = 0;
    }
    
    document.getElementById('dd').textContent = dd.toFixed(1) + '%';
    document.getElementById('heat').textContent = Math.round(heat) + '%';
    document.getElementById('heat').className = heat > 70 ? 'r' : heat > 50 ? 'y' : 'g';
    
    if (dd >= C.maxDD) {
        document.getElementById('shield').textContent = 'SHIELD:üõë';
        document.getElementById('shield').className = 'badge off';
        sendAlert(`üö® MAX DRAWDOWN REACHED: ${dd.toFixed(1)}%\nAll positions closed.`, 'danger');
        return false;
    }
    
    document.getElementById('shield').textContent = 'SHIELD:‚úì';
    document.getElementById('shield').className = 'badge on';
    return true;
}

function calcLotSize(sym) {
    const vol = calcVolatility(sym);
    const p = prices[sym];
    const volFactor = p ? Math.max(0.5, 1 - vol / p.mid * 100) : 1;
    const streakFactor = S.streak < -2 ? 0.5 : 1;
    const lot = Math.max(0.01, Math.min(0.05, C.baseLot * volFactor * streakFactor));
    document.getElementById('lotSize').textContent = lot.toFixed(2);
    return lot;
}

function getUnrealized() {
    let u = 0;
    S.pos.forEach(pos => {
        const p = prices[pos.sym];
        if (!p) return;
        const cur = pos.type === 'BUY' ? p.bid : p.ask;
        const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
        u += pips * pos.pipValue;
    });
    return u;
}

function hasCorrelatedPosition(sym) {
    const corr = getCorrelatedPairs(sym);
    return S.pos.some(p => corr.includes(p.sym) || p.sym === sym);
}

function generateTradeId() {
    return 'HFT-' + Date.now().toString(36).toUpperCase() + '-' + Math.random().toString(36).substring(2, 6).toUpperCase();
}

function trade() {
    if (!checkRiskShield()) return;
    const now = Date.now();
    
    SYM.forEach(sym => {
        const p = prices[sym.s];
        if (!p) return;
        if (lastTrade[sym.s] && now - lastTrade[sym.s] < C.cooldown) return;
        if (hasCorrelatedPosition(sym.s)) return;
        if (S.pos.length >= C.maxPos) return;
        
        const { sig, strength } = getSignal(sym.s);
        if (sig) {
            const lot = calcLotSize(sym.s);
            const pipValue = lot * 10000 * sym.p;
            const isBuy = sig === 'BUY';
            const entry = isBuy ? p.ask : p.bid;
            const tradeId = generateTradeId();
            
            const newPos = {
                id: tradeId,
                sym: sym.s,
                type: sig,
                entry,
                tp: isBuy ? entry + C.tp * sym.p : entry - C.tp * sym.p,
                sl: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
                trail: null,
                pipValue,
                pip: sym.p,
                lot,
                strength,
                time: now
            };
            
            S.pos.push(newPos);
            
            // üîó FORWARD SIGNAL VIA TELEGRAM
            forwardSignalToTelegram({
                action: 'OPEN',
                trade_id: tradeId,
                symbol: sym.s,
                direction: sig,
                entry_price: entry,
                take_profit: newPos.tp,
                stop_loss: newPos.sl,
                lot_size: lot,
                signal_strength: strength,
                timestamp: new Date().toISOString()
            });
            
            lastTrade[sym.s] = now;
            log(`üìà ${sig} ${sym.s} @${fmtP(sym.s, entry)} [${strength}‚òÖ]`, isBuy ? 'g' : 'r');
            save();
        }
    });
    
    managePositions();
}

function managePositions() {
    const toClose = [];
    
    S.pos.forEach((pos, i) => {
        const p = prices[pos.sym];
        if (!p) return;
        
        const isBuy = pos.type === 'BUY';
        const cur = isBuy ? p.bid : p.ask;
        const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
        const pnl = pips * pos.pipValue;
        
        // Trailing Stop Logic
        if (pips >= C.trail) {
            const newTrail = isBuy ? cur - (2 * pos.pip) : cur + (2 * pos.pip);
            if (!pos.trail || (isBuy ? newTrail > pos.trail : newTrail < pos.trail)) {
                pos.trail = newTrail;
            }
        }
        
        // Check Exits
        let reason = null;
        if (isBuy) {
            if (cur >= pos.tp) reason = "TP";
            else if (cur <= pos.sl) reason = "SL";
            else if (pos.trail && cur <= pos.trail) reason = "TRAIL";
        } else {
            if (cur <= pos.tp) reason = "TP";
            else if (cur >= pos.sl) reason = "SL";
            else if (pos.trail && cur >= pos.trail) reason = "TRAIL";
        }
        
        if (reason) {
            toClose.push({ index: i, reason, exitPrice: cur, pips, pnl, pos });
        }
    });
    
    // Process Closures
    toClose.reverse().forEach(c => {
        const p = S.pos.splice(c.index, 1)[0];
        
        // Update Stats
        S.bal += c.pnl;
        dailyPnL += c.pnl;
        if (c.pnl > 0) {
            S.wins++;
            S.grossWin += c.pnl;
            S.streak = Math.max(0, S.streak + 1);
        } else {
            S.losses++;
            S.grossLoss += Math.abs(c.pnl);
            S.streak = Math.min(0, S.streak - 1);
        }
        
        if (S.bal > S.peak) S.peak = S.bal;
        S.returns.push(c.pnl);
        
        // üîó FORWARD CLOSE SIGNAL VIA TELEGRAM
        forwardSignalToTelegram({
            action: 'CLOSE',
            trade_id: p.id,
            symbol: p.sym,
            exit_reason: c.reason,
            exit_price: c.exitPrice,
            pnl_usd: c.pnl,
            pnl_pips: c.pips,
            duration_ms: Date.now() - p.time,
            timestamp: new Date().toISOString()
        });
        
        log(`üèÅ ${c.reason} ${p.sym}: ${c.pnl > 0 ? '+' : ''}$${c.pnl.toFixed(2)} (${c.pips.toFixed(1)} pips)`, c.pnl > 0 ? 'g' : 'r');
    });
    
    if (toClose.length > 0) {
        S.eq.push(S.bal);
        save();
    }
}

function render() {
    const equity = S.bal + getUnrealized();
    const pnl = equity - C.start;
    
    document.getElementById('equity').textContent = '$' + equity.toFixed(2);
    document.getElementById('equity').className = pnl >= 0 ? 'g' : 'r';
    document.getElementById('pnl').textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
    document.getElementById('pnlPct').textContent = (pnl >= 0 ? '+' : '') + (pnl / C.start * 100).toFixed(2) + '%';
    
    document.getElementById('trades').textContent = S.wins + S.losses;
    const wr = (S.wins + S.losses) > 0 ? (S.wins / (S.wins + S.losses) * 100) : 0;
    document.getElementById('winrate').textContent = wr.toFixed(1) + '%';
    document.getElementById('winrate').className = wr >= 50 ? 'g' : wr >= 40 ? 'y' : 'r';
    
    const pf = S.grossLoss > 0 ? (S.grossWin / S.grossLoss).toFixed(2) : '‚àû';
    document.getElementById('pf').textContent = pf;
    
    document.getElementById('openPos').textContent = S.pos.length + '/' + C.maxPos;
    document.getElementById('streak').textContent = (S.streak > 0 ? '+' : '') + S.streak;
    document.getElementById('streak').className = S.streak > 0 ? 'g' : S.streak < 0 ? 'r' : '';
    document.getElementById('best').textContent = '$' + S.best.toFixed(2);
    document.getElementById('avgWin').textContent = '$' + (S.wins > 0 ? (S.grossWin / S.wins).toFixed(2) : '0');
    document.getElementById('avgLoss').textContent = '$' + (S.losses > 0 ? (S.grossLoss / S.losses).toFixed(2) : '0');
    
    // Update Market Table
    let marketHTML = '';
    SYM.forEach(s => {
        const p = prices[s.s];
        if (!p) return;
        const sig = getSignal(s.s);
        
        // Find position P&L
        let posPnl = 0;
        const pos = S.pos.find(pos => pos.sym === s.s);
        if (pos) {
            const cur = pos.type === 'BUY' ? p.bid : p.ask;
            const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
            posPnl = pips * pos.pipValue;
        }
        
        marketHTML += `<tr>
            <td><b>${s.s}</b></td>
            <td>${p.bid.toFixed(5)}</td>
            <td>${p.ask.toFixed(5)}</td>
            <td class="${p.change24 >= 0 ? 'g' : 'r'}">${(p.change24 || 0).toFixed(2)}%</td>
            <td class="${sig.rsi < 30 ? 'g' : sig.rsi > 70 ? 'r' : ''}">${sig.rsi}</td>
            <td class="${sig.mom > 0 ? 'g' : sig.mom < 0 ? 'r' : ''}">${sig.mom}</td>
            <td class="${sig.sig === 'BUY' ? 'g' : sig.sig === 'SELL' ? 'r' : 'dim'}">${sig.sig || '--'}</td>
            <td class="${posPnl >= 0 ? 'g' : 'r'}">${posPnl >= 0 ? '+' : ''}$${posPnl.toFixed(2)}</td>
        </tr>`;
    });
    document.getElementById('market').innerHTML = marketHTML;
    
    // Update Positions
    if (S.pos.length === 0) {
        document.getElementById('positions').innerHTML = '<span class="dim">No open positions</span>';
    } else {
        let positionsHTML = '';
        S.pos.forEach(pos => {
            const p = prices[pos.sym];
            if (!p) return;
            const cur = pos.type === 'BUY' ? p.bid : p.ask;
            const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
            const pnl = pips * pos.pipValue;
            positionsHTML += `<div class="log" style="border-left:2px solid ${pnl >= 0 ? 'var(--g)' : 'var(--r)'}">
                ${pos.type === 'BUY' ? 'üü¢' : 'üî¥'} ${pos.sym} ${pos.type} @${fmtP(pos.sym, pos.entry)}
                <span class="${pnl >= 0 ? 'g' : 'r'}">${pips >= 0 ? '+' : ''}${pips.toFixed(1)}p ($${pnl.toFixed(2)})</span>
            </div>`;
        });
        document.getElementById('positions').innerHTML = positionsHTML;
    }
    
    // Update time
    document.getElementById('time').textContent = new Date().toLocaleTimeString();
    
    // Update equity chart
    S.eq.push(equity);
    if (S.eq.length > 60) S.eq.shift();
    const min = Math.min(...S.eq) * 0.98;
    const max = Math.max(...S.eq) * 1.02;
    const range = max - min || 1;
    
    let chartHTML = '';
    S.eq.forEach((v, i) => {
        const h = Math.max(4, ((v - min) / range) * 100);
        const c = v >= C.start ? 'var(--g)' : 'var(--r)';
        const o = 0.3 + (i / S.eq.length) * 0.7;
        chartHTML += `<div style="height:${h}%;background:${c};opacity:${o}"></div>`;
    });
    document.getElementById('chart').innerHTML = chartHTML;
}

function log(msg, cls) {
    const entry = { msg, cls, t: Date.now() };
    logs.unshift(entry);
    if (logs.length > 20) logs.pop();
    
    const logEl = document.getElementById('log');
    const div = document.createElement('div');
    div.className = 'log ' + (cls || '');
    div.innerHTML = `<span class="dim">[${new Date(entry.t).toLocaleTimeString()}]</span> ${msg}`;
    logEl.prepend(div);
    if (logEl.children.length > 50) logEl.lastChild.remove();
}

function fmtP(s, v) {
    const pair = SYM.find(x => x.s === s);
    return v.toFixed(pair && pair.mt5.includes('JPY') ? 2 : 5);
}

// =====================================================
// INITIALIZATION
// =====================================================
async function init() {
    loadTelegramConfig();
    log('üöÄ HFT ULTRA 2026 - Telegram Bridge Starting...', 'b');
    log('üì° Connecting to Binance API...', 'b');
    
    const ok = await fetchBinancePrices();
    if (ok) {
        log('‚úÖ Binance API connected', 'g');
        updatePrices();
        render();
        
        // Send startup alert
        if (telegramConfig.botToken && telegramConfig.chatId) {
            sendAlert('üöÄ HFT ULTRA 2026 Telegram Bridge Started\nSystem is now monitoring 29 crypto pairs.');
        }
        
        // Start trading engine
        setInterval(async () => {
            const apiOk = await fetchBinancePrices();
            if (apiOk) {
                updatePrices();
                trade();
                render();
            }
        }, 2000);
        
        // Update status
        document.getElementById('status').textContent = 'üü¢ LIVE';
        document.getElementById('status').className = 'badge on';
        
    } else {
        log('‚ùå Failed to connect to Binance', 'r');
        document.getElementById('status').textContent = 'üî¥ ERROR';
        document.getElementById('status').className = 'badge off';
    }
}

// Start the system
init();
</script>
</body>
</html>
