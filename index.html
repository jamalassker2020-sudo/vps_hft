<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>HFT Ultra FX 2026 - Smart Profit Lock</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0e14;--card:#121820;--border:#1a2030;--txt:#c8d0dc;--dim:#5a6270;--g:#0f6;--r:#f44;--b:#0af;--y:#fc0;--gold:#ffd700}
html.light{--bg:#f4f6f8;--card:#fff;--border:#dde;--txt:#1a1a2e;--dim:#888}
body{background:var(--bg);color:var(--txt);font:11px/1.4 monospace;padding:8px;min-height:100vh}
.g{color:var(--g)}.r{color:var(--r)}.b{color:var(--b)}.y{color:var(--y)}.dim{color:var(--dim)}.gold{color:var(--gold)}
.card{background:var(--card);border:1px solid var(--border);border-radius:4px;padding:8px;margin-bottom:8px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.col{flex:1;min-width:120px}
.grid{display:grid;gap:4px}
.g2{grid-template-columns:repeat(2,1fr)}.g3{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(4,1fr)}.g6{grid-template-columns:repeat(6,1fr)}
.stat{background:var(--bg);padding:6px;border-radius:3px;text-align:center}
.stat small{display:block;font-size:9px;color:var(--dim);margin-bottom:2px}
.stat b{font-size:13px}
h1{font-size:14px;margin-bottom:4px}
table{width:100%;border-collapse:collapse;font-size:10px}
th,td{padding:4px;text-align:right}
th{color:var(--dim);font-weight:400;border-bottom:1px solid var(--border)}
td:first-child,th:first-child{text-align:left}
tr:hover{background:rgba(255,255,255,.02)}
.scroll{max-height:200px;overflow-y:auto}
.bar{height:40px;display:flex;align-items:end;gap:1px}
.bar div{flex:1;min-width:2px;border-radius:1px 1px 0 0}
.log{font-size:9px;padding:2px 4px;margin:1px 0;border-radius:2px;background:var(--bg)}
button{background:var(--card);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;cursor:pointer;font:inherit}
button:hover{background:var(--border)}
.pulse{animation:p 1.5s infinite}@keyframes p{50%{opacity:.5}}
.badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px}
.badge.on{background:#0f62;color:var(--g)}.badge.off{background:#f442;color:var(--r)}.badge.warn{background:#fc02;color:var(--y)}.badge.gold{background:#ffd7002a;color:var(--gold)}
input[type="text"]{background:var(--bg);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;font:inherit;width:100%;font-size:16px}
input[type="text"]:focus{outline:none;border-color:var(--b)}
.webhook-status{font-size:9px;margin-top:4px}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:400px;width:90%}
.modal h3{margin-bottom:12px;font-size:14px}
.modal-buttons{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
.profit-bar{height:6px;background:var(--border);border-radius:3px;overflow:hidden;margin-top:4px}
.profit-bar-fill{height:100%;transition:width 0.3s;border-radius:3px}
.lock-flash{animation:lockFlash 0.5s ease-out}
@keyframes lockFlash{0%{background:var(--gold);transform:scale(1.05)}100%{background:var(--bg);transform:scale(1)}}
@media(max-width:600px){.g6{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>
<div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
<div>
<h1>‚ö° HFT ULTRA <span class="y">FX</span> <span class="gold">SMART LOCK</span> <span class="dim">2026</span></h1>
<small class="dim">28 PAIRS ‚Ä¢ ACCUMULATING PROFIT LOCK ‚Ä¢ TIERED TRAILS ‚Ä¢ BREAK-EVEN LOCK</small>
</div>
<div class="row" style="gap:4px">
<span id="status" class="badge pulse">INIT</span>
<span id="mode" class="badge">MODE:--</span>
<span id="api" class="badge dim">API:--</span>
<span id="webhook" class="badge dim">WH:--</span>
<span id="shield" class="badge">SHIELD:--</span>
<button onclick="showWebhookConfig()">‚öôÔ∏è</button>
<button onclick="reset()">‚ü≤</button>
</div>
</div>

<div class="grid g6" style="margin-bottom:8px">
<div class="stat"><small>üí∞ EQUITY</small><b id="equity" class="g">$100.00</b><div id="pnlPct" style="font-size:9px">+0.00%</div></div>
<div class="stat" id="lockedStat"><small>üîí LOCKED (‚àû)</small><b id="locked" class="gold">$0.00</b><div id="lockPct" style="font-size:9px;color:var(--gold)">0 locks</div></div>
<div class="stat"><small>TRADES</small><b id="trades" class="b">0</b></div>
<div class="stat"><small>WIN%</small><b id="winrate" class="y">0%</b></div>
<div class="stat"><small>PROFIT F.</small><b id="pf" class="g">0.00</b></div>
<div class="stat"><small>OPEN</small><b id="openPos" class="b">0/6</b></div>
<div class="stat"><small>STREAK</small><b id="streak">0</b></div>
<div class="stat"><small>PEAK</small><b id="best" class="g">$100</b></div>
<div class="stat"><small>DD</small><b id="dd" class="r">0%</b></div>
<div class="stat"><small>TODAY</small><b id="todayPnl" class="g">$0</b></div>
<div class="stat"><small>AVG WIN</small><b id="avgWin" class="g">$0</b></div>
<div class="stat"><small>SHARPE</small><b id="sharpe" class="b">0.00</b></div>
</div>

<!-- Profit Protection Status -->
<div class="card" style="padding:6px">
<div class="row" style="justify-content:space-between;align-items:center">
<div style="flex:1">
<small class="dim">üéØ DAILY TARGET</small>
<div class="profit-bar"><div id="targetBar" class="profit-bar-fill" style="width:0%;background:var(--g)"></div></div>
</div>
<div style="flex:1;margin-left:12px">
<small class="dim">üîí NEXT LOCK @<span id="nextLockAt">$102</span></small>
<div class="profit-bar"><div id="lockBar" class="profit-bar-fill" style="width:0%;background:var(--gold)"></div></div>
</div>
<div style="flex:1;margin-left:12px">
<small class="dim">üî• RISK HEAT</small>
<div class="profit-bar"><div id="heatBar" class="profit-bar-fill" style="width:0%;background:var(--r)"></div></div>
</div>
</div>
</div>

<div class="row">
<div class="col" style="flex:3">
<div class="card">
<div class="row" style="justify-content:space-between;margin-bottom:4px">
<b class="b">üìä FOREX MARKET</b>
<span id="time" class="dim">--:--:--</span>
</div>
<div class="scroll"><table><thead><tr><th>PAIR</th><th>BID</th><th>ASK</th><th>SPR</th><th>RSI</th><th>MOM</th><th>SIG</th><th>P&L</th></tr></thead><tbody id="market"></tbody></table></div>
</div>
</div>
<div class="col">
<div class="card">
<b>üìà POSITIONS</b>
<div id="positions" class="scroll" style="margin-top:4px"><span class="dim">Scanning...</span></div>
</div>
<div class="card">
<b>‚ö° LOG</b>
<div id="log" class="scroll" style="margin-top:4px"><span class="dim">Starting...</span></div>
</div>
</div>
</div>

<div class="row">
<div class="col">
<div class="card"><b>üíπ EQUITY</b><div class="bar" id="chart"></div></div>
</div>
<div class="col">
<div class="card">
<b>üõ°Ô∏è ACCUMULATING PROFIT LOCK</b>
<div class="grid g3" style="margin-top:6px;font-size:9px;text-align:center">
<div class="stat"><small>LOCK STEP</small><span id="lockStep" class="gold">$2</span></div>
<div class="stat"><small>LOCK %</small><span id="lockPctStat" class="gold">50%</span></div>
<div class="stat"><small>LOCK COUNT</small><span id="lockCount" class="gold">0</span></div>
<div class="stat"><small>BE TRIGGER</small><span id="beTrigger" class="g">3p</span></div>
<div class="stat"><small>TRAIL START</small><span id="trailStart" class="y">5p</span></div>
<div class="stat"><small>LOT</small><span id="lotSize" class="b">0.01</span></div>
</div>
</div>
</div>
</div>

<!-- Webhook Config Modal -->
<div id="webhookModal" class="modal-overlay" style="display:none">
<div class="modal">
<h3>üîó MT5 Webhook Configuration</h3>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">Webhook URL (your MT5 EA endpoint)</label>
<input type="text" id="webhookUrl" placeholder="http://localhost:5000/webhook">
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">Secret Key (optional)</label>
<input type="text" id="webhookSecret" placeholder="your-secret-key">
</div>
<div class="grid g2" style="margin-bottom:12px">
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="whOpenEnabled" checked> Send on OPEN
</label>
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="whCloseEnabled" checked> Send on CLOSE
</label>
</div>
<div class="webhook-status" id="webhookTestResult"></div>
<div class="modal-buttons">
<button onclick="testWebhook()">üß™ Test</button>
<button onclick="saveWebhookConfig()">üíæ Save</button>
<button onclick="closeWebhookModal()">‚úï Close</button>
</div>
</div>
</div>

<script>
// Dark/Light mode
if(matchMedia('(prefers-color-scheme:light)').matches)document.documentElement.classList.add('light');
matchMedia('(prefers-color-scheme:light)').onchange=e=>document.documentElement.classList.toggle('light',e.matches);

// =====================================================
// FOREX INSTRUMENTS (28 pairs)
// =====================================================
const SYM=[
  {s:'EUR/USD',base:'EUR',quote:'USD',p:0.0001,t:'major',mt5:'EURUSD',spread:1.2},
  {s:'GBP/USD',base:'GBP',quote:'USD',p:0.0001,t:'major',mt5:'GBPUSD',spread:1.5},
  {s:'USD/JPY',base:'USD',quote:'JPY',p:0.01,t:'major',mt5:'USDJPY',spread:1.3},
  {s:'USD/CHF',base:'USD',quote:'CHF',p:0.0001,t:'major',mt5:'USDCHF',spread:1.8},
  {s:'AUD/USD',base:'AUD',quote:'USD',p:0.0001,t:'major',mt5:'AUDUSD',spread:1.4},
  {s:'USD/CAD',base:'USD',quote:'CAD',p:0.0001,t:'major',mt5:'USDCAD',spread:1.6},
  {s:'NZD/USD',base:'NZD',quote:'USD',p:0.0001,t:'major',mt5:'NZDUSD',spread:1.8},
  {s:'EUR/GBP',base:'EUR',quote:'GBP',p:0.0001,t:'cross',mt5:'EURGBP',spread:1.5},
  {s:'EUR/JPY',base:'EUR',quote:'JPY',p:0.01,t:'cross',mt5:'EURJPY',spread:1.8},
  {s:'EUR/CHF',base:'EUR',quote:'CHF',p:0.0001,t:'cross',mt5:'EURCHF',spread:2.0},
  {s:'EUR/AUD',base:'EUR',quote:'AUD',p:0.0001,t:'cross',mt5:'EURAUD',spread:2.5},
  {s:'EUR/CAD',base:'EUR',quote:'CAD',p:0.0001,t:'cross',mt5:'EURCAD',spread:2.2},
  {s:'EUR/NZD',base:'EUR',quote:'NZD',p:0.0001,t:'cross',mt5:'EURNZD',spread:3.0},
  {s:'GBP/JPY',base:'GBP',quote:'JPY',p:0.01,t:'cross',mt5:'GBPJPY',spread:2.5},
  {s:'GBP/CHF',base:'GBP',quote:'CHF',p:0.0001,t:'cross',mt5:'GBPCHF',spread:2.8},
  {s:'GBP/AUD',base:'GBP',quote:'AUD',p:0.0001,t:'cross',mt5:'GBPAUD',spread:3.0},
  {s:'GBP/CAD',base:'GBP',quote:'CAD',p:0.0001,t:'cross',mt5:'GBPCAD',spread:2.8},
  {s:'GBP/NZD',base:'GBP',quote:'NZD',p:0.0001,t:'cross',mt5:'GBPNZD',spread:3.5},
  {s:'AUD/JPY',base:'AUD',quote:'JPY',p:0.01,t:'cross',mt5:'AUDJPY',spread:2.0},
  {s:'AUD/NZD',base:'AUD',quote:'NZD',p:0.0001,t:'cross',mt5:'AUDNZD',spread:2.5},
  {s:'AUD/CAD',base:'AUD',quote:'CAD',p:0.0001,t:'cross',mt5:'AUDCAD',spread:2.2},
  {s:'AUD/CHF',base:'AUD',quote:'CHF',p:0.0001,t:'cross',mt5:'AUDCHF',spread:2.5},
  {s:'NZD/JPY',base:'NZD',quote:'JPY',p:0.01,t:'cross',mt5:'NZDJPY',spread:2.5},
  {s:'NZD/CAD',base:'NZD',quote:'CAD',p:0.0001,t:'cross',mt5:'NZDCAD',spread:2.8},
  {s:'NZD/CHF',base:'NZD',quote:'CHF',p:0.0001,t:'cross',mt5:'NZDCHF',spread:3.0},
  {s:'CAD/JPY',base:'CAD',quote:'JPY',p:0.01,t:'cross',mt5:'CADJPY',spread:2.2},
  {s:'CAD/CHF',base:'CAD',quote:'CHF',p:0.0001,t:'cross',mt5:'CADCHF',spread:2.5},
  {s:'XAU/USD',base:'XAU',quote:'USD',p:0.01,t:'metal',mt5:'XAUUSD',spread:25}
];

// =====================================================
// SMART PROFIT LOCK CONFIGURATION
// =====================================================
const C={
  start:100,
  baseLot:0.01,
  
  // *** PROFIT PROTECTION SETTINGS ***
  tp:15,               // 15 pip TP (3:1 RR)
  sl:5,                // 5 pip SL tight
  
  // Break-even system
  breakEvenTrigger:3,  // Move SL to break-even after 3 pips profit
  breakEvenPlus:0.5,   // Add 0.5 pip above entry when at break-even
  
  // Tiered trailing stop system
  trail1Trigger:5,     // Start trailing at 5 pips
  trail1Distance:2,    // Trail 2 pips behind
  trail2Trigger:8,     // Tighter trail at 8 pips  
  trail2Distance:1.5,  // Trail 1.5 pips behind
  trail3Trigger:12,    // Very tight at 12 pips
  trail3Distance:1,    // Trail 1 pip behind
  
  // Partial profit taking
  partial1Trigger:6,   // Close 50% at 6 pips profit
  partial1Pct:0.5,     // Close 50% of position
  
  // *** ACCUMULATING PROFIT LOCK ***
  // Every time equity grows by lockStep, we permanently lock lockPct of that step
  profitLockStep:2,    // Lock profits every $2 gain
  profitLockPct:50,    // Lock 50% of each step ($1 per $2 gain)
  
  dailyTarget:3,       // 3% daily target - reduce risk after
  dailyLossLimit:2,    // 2% daily loss limit - stop trading
  
  // Time-based exits
  maxHoldTime:300000,  // 5 min max hold - close if stagnant
  stagnantThreshold:2, // If less than 2 pips in 3 mins, consider exit
  
  // Momentum exit signals
  momentumExitThreshold:0.03, // Exit if momentum reverses strongly
  rsiExitBuffer:10,    // Exit if RSI moves 10 points against position
  
  // Risk settings
  maxPos:6,
  maxDD:5,
  cooldown:5000,
  rsiPeriod:14,
  minRSI:25,
  maxRSI:75,
  minStrength:3,
  spreadMax:3
};

// =====================================================
// WEBHOOK CONFIGURATION FOR MT5 - PRE-CONFIGURED
// =====================================================
let webhookConfig = {
  // PRE-CONFIGURED WITH YOUR SERVER (Update port if needed)
  url: 'http://caboose.proxy.rlwy.net:24843/webhook',
  secret: '',
  openEnabled: true,
  closeEnabled: true,
  lastStatus: null,
  sentCount: 0,
  errorCount: 0
};

function loadWebhookConfig() {
  try {
    const hash = location.hash.slice(1);
    if (hash) {
      const data = JSON.parse(atob(hash));
      if (data.webhook) {
        webhookConfig = { ...webhookConfig, ...data.webhook };
      }
    }
  } catch (e) {
    console.log('No webhook config found');
  }
  updateWebhookUI();
}

function saveWebhookConfig() {
  webhookConfig.url = document.getElementById('webhookUrl').value.trim();
  webhookConfig.secret = document.getElementById('webhookSecret').value.trim();
  webhookConfig.openEnabled = document.getElementById('whOpenEnabled').checked;
  webhookConfig.closeEnabled = document.getElementById('whCloseEnabled').checked;
  
  save();
  updateWebhookUI();
  closeWebhookModal();
  log('üîó Webhook config saved', 'b');
}

function updateWebhookUI() {
  const el = document.getElementById('webhook');
  if (webhookConfig.url) {
    el.textContent = 'WH:‚úì';
    el.className = 'badge on';
  } else {
    el.textContent = 'WH:OFF';
    el.className = 'badge dim';
  }
}

function showWebhookConfig() {
  document.getElementById('webhookUrl').value = webhookConfig.url;
  document.getElementById('webhookSecret').value = webhookConfig.secret;
  document.getElementById('whOpenEnabled').checked = webhookConfig.openEnabled;
  document.getElementById('whCloseEnabled').checked = webhookConfig.closeEnabled;
  document.getElementById('webhookModal').style.display = 'flex';
}

function closeWebhookModal() {
  document.getElementById('webhookModal').style.display = 'none';
}

function generateTradeId() {
  return 'HFT-' + Date.now().toString(36).toUpperCase() + '-' + Math.random().toString(36).substring(2, 6).toUpperCase();
}

// Webhook sender - MODIFIED FOR HTTP & CORS
async function sendWebhook(action, tradeData) {
  if (!webhookConfig.url) return;
  if (action === 'OPEN' && !webhookConfig.openEnabled) return;
  if (action === 'CLOSE' && !webhookConfig.closeEnabled) return;

  const symData = SYM.find(s => s.s === tradeData.sym);
  
  const payload = {
    action: action,
    source: "HFT-ULTRA-FX-SMARTLOCK-2026",
    version: "2.0",
    timestamp: new Date().toISOString(),
    timestamp_unix: Date.now(),
    trade_id: tradeData.id || generateTradeId(),
    symbol: tradeData.sym,
    symbol_mt5: symData?.mt5 || tradeData.sym.replace('/', ''),
    direction: tradeData.type,
    order_type: tradeData.type === 'BUY' ? 0 : 1,
    entry_price: tradeData.entry,
    current_price: tradeData.currentPrice || tradeData.entry,
    take_profit: tradeData.tp,
    stop_loss: tradeData.sl,
    trailing_stop: tradeData.trail || null,
    lot_size: tradeData.lot,
    pip_value: tradeData.pipValue,
    pip_size: tradeData.pip,
    signal_strength: tradeData.strength || 0,
    exit_price: action === 'CLOSE' ? tradeData.exitPrice : null,
    exit_reason: action === 'CLOSE' ? tradeData.reason : null,
    pnl_pips: action === 'CLOSE' ? tradeData.pips : null,
    pnl_usd: action === 'CLOSE' ? tradeData.pnl : null,
    duration_ms: action === 'CLOSE' ? (Date.now() - tradeData.time) : null,
    account: {
      balance: S.bal,
      equity: S.bal + getUnrealized(),
      locked_profit: S.lockedProfit || 0,
      lock_count: S.lockCount || 0,
      open_positions: S.pos.length,
      total_trades: S.wins + S.losses,
      win_rate: S.wins + S.losses > 0 ? (S.wins / (S.wins + S.losses) * 100).toFixed(2) : 0
    },
    auth: webhookConfig.secret ? {
      secret: webhookConfig.secret,
      signature: btoa(webhookConfig.secret + ':' + Date.now())
    } : null
  };

  try {
    const response = await fetch(webhookConfig.url, {
      method: 'POST',
      // IMPORTANT: Headers modified for HTTP/CORS compatibility
      headers: {
        'Content-Type': 'application/json',
        'X-Signal-Source': 'HFT-ULTRA-FX-SMARTLOCK-2026',
        'X-Signal-Action': action,
        ...(webhookConfig.secret && { 'X-Auth-Key': webhookConfig.secret }),
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      },
      body: JSON.stringify(payload),
      // CRITICAL: 'no-cors' mode for HTTP servers without proper CORS headers
      mode: 'no-cors',
      // Keep-alive for better connection
      keepalive: true
    });

    // Note: In 'no-cors' mode, response will be opaque - we can't read it
    // But we can assume success if no network error
    webhookConfig.sentCount++;
    webhookConfig.lastStatus = 'OK';
    log(`üîó WH ${action}: ${tradeData.sym}`, 'b');
    
  } catch (err) {
    webhookConfig.errorCount++;
    webhookConfig.lastStatus = 'ERR';
    console.log('Webhook error:', JSON.stringify(err.message));
    if (webhookConfig.errorCount <= 3) {
      log(`‚ö†Ô∏è WH Error: ${err.message}`, 'y');
    }
  }
}

async function testWebhook() {
  const url = document.getElementById('webhookUrl').value.trim();
  const resultEl = document.getElementById('webhookTestResult');
  
  if (!url) {
    resultEl.innerHTML = '<span class="r">‚ùå Please enter a webhook URL</span>';
    return;
  }

  resultEl.innerHTML = '<span class="y">üîÑ Testing...</span>';

  try {
    // Test with 'cors' mode first to see if server responds
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Signal-Source': 'HFT-ULTRA-FX-SMARTLOCK-2026',
        'X-Signal-Action': 'TEST'
      },
      body: JSON.stringify({
        action: 'TEST',
        source: 'HFT-ULTRA-FX-SMARTLOCK-2026',
        version: '2.0',
        timestamp: new Date().toISOString(),
        message: 'Connection test from HFT Ultra FX Smart Lock 2026'
      }),
      mode: 'cors'
    });

    if (response.ok) {
      resultEl.innerHTML = '<span class="g">‚úÖ Connection successful!</span>';
    } else {
      resultEl.innerHTML = `<span class="r">‚ùå HTTP Error: ${response.status}</span>`;
    }
  } catch (err) {
    // If CORS fails, try 'no-cors' mode
    try {
      await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Signal-Source': 'HFT-ULTRA-FX-SMARTLOCK-2026',
          'X-Signal-Action': 'TEST'
        },
        body: JSON.stringify({
          action: 'TEST',
          source: 'HFT-ULTRA-FX-SMARTLOCK-2026',
          version: '2.0',
          timestamp: new Date().toISOString(),
          message: 'Connection test from HFT Ultra FX Smart Lock 2026'
        }),
        mode: 'no-cors'
      });
      resultEl.innerHTML = '<span class="y">‚ö†Ô∏è Connected (no-cors mode)</span>';
    } catch (err2) {
      resultEl.innerHTML = `<span class="r">‚ùå ${err2.message}</span>`;
    }
  }
}

// State
let S=load()||fresh();
let prices={},history={},lastTrade={},logs=[],ticks=0,dailyPnL=0,dayStart=new Date().toDateString();
let ecbRates={};
let tradingMode = 'NORMAL'; // NORMAL, DEFENSIVE, LOCKED

function fresh(){
  return {
    bal:C.start,
    pos:[],
    wins:0,
    losses:0,
    grossWin:0,
    grossLoss:0,
    eq:[C.start],
    streak:0,
    best:C.start,
    peak:C.start,
    returns:[],
    lockedProfit:0,         // Total accumulated locked profit
    lockCount:0,            // Number of times profit was locked
    lastLockLevel:C.start,  // Last equity level where we locked profit
    sessionPeak:C.start,    // Peak equity this session
    dailyStartBal:C.start
  };
}

function load(){
  try{
    const data = JSON.parse(atob(location.hash.slice(1)));
    if (data.webhook) {
      webhookConfig = { ...webhookConfig, ...data.webhook };
    }
    // Ensure new fields exist
    data.lockedProfit = data.lockedProfit || 0;
    data.lockCount = data.lockCount || 0;
    data.lastLockLevel = data.lastLockLevel || C.start;
    data.sessionPeak = data.sessionPeak || data.peak || C.start;
    data.dailyStartBal = data.dailyStartBal || C.start;
    return data;
  } catch(e) {
    return null;
  }
}

function save(){
  try{
    const data = {
      ...S,
      eq: S.eq.slice(-60),
      returns: S.returns.slice(-100),
      webhook: {
        url: webhookConfig.url,
        secret: webhookConfig.secret,
        openEnabled: webhookConfig.openEnabled,
        closeEnabled: webhookConfig.closeEnabled
      }
    };
    history.replaceState(null, '', '#' + btoa(JSON.stringify(data)));
  } catch(e) {}
}

function reset(){
  S=fresh();
  logs=[];
  prices={};
  history={};
  dailyPnL=0;
  ecbRates={};
  tradingMode='NORMAL';
  save();
  render();
}

// =====================================================
// FOREX PRICE DATA - ECB + Simulated Ticks
// =====================================================

async function fetchECBRates(){
  try{
    const r = await fetch('https://api.frankfurter.app/latest?from=USD');
    const data = await r.json();
    
    ecbRates = {
      'USD': 1,
      'EUR': 1 / data.rates.EUR,
      'GBP': 1 / data.rates.GBP,
      'JPY': data.rates.JPY,
      'CHF': data.rates.CHF,
      'AUD': 1 / data.rates.AUD,
      'CAD': data.rates.CAD,
      'NZD': 1 / data.rates.NZD,
    };
    
    ecbRates['XAU'] = 2650 + (Math.random() - 0.5) * 20;
    
    document.getElementById('api').textContent='API:ECB‚úì';
    document.getElementById('api').className='badge on';
    return true;
  }catch(e){
    console.log('ECB API error:', JSON.stringify(e));
    ecbRates = {
      'USD': 1,
      'EUR': 1.0850,
      'GBP': 1.2650,
      'JPY': 149.50,
      'CHF': 0.8850,
      'AUD': 0.6550,
      'CAD': 1.3550,
      'NZD': 0.6150,
      'XAU': 2650
    };
    document.getElementById('api').textContent='API:SIM';
    document.getElementById('api').className='badge warn';
    return true;
  }
}

function getCrossRate(base, quote) {
  if (base === 'USD') {
    return ecbRates[quote] || 1;
  } else if (quote === 'USD') {
    return ecbRates[base] || 1;
  } else {
    const baseUSD = ecbRates[base] || 1;
    const quoteUSD = ecbRates[quote] || 1;
    
    if (quote === 'JPY') {
      return baseUSD * ecbRates['JPY'];
    }
    if (base === 'JPY') {
      return 1 / (quoteUSD * ecbRates['JPY']);
    }
    
    return baseUSD / quoteUSD;
  }
}

function simulateTick(sym, basePrice) {
  const pip = sym.p;
  const volatility = sym.t === 'metal' ? 0.5 : (sym.t === 'major' ? 0.3 : 0.4);
  const change = (Math.random() - 0.5) * volatility * pip * 10;
  return basePrice + change;
}

function updatePrices(){
  SYM.forEach(sym => {
    let baseMid = getCrossRate(sym.base, sym.quote);
    const prevMid = prices[sym.s]?.mid || baseMid;
    const newMid = simulateTick(sym, prevMid);
    const reversion = (baseMid - newMid) * 0.01;
    const mid = newMid + reversion;
    
    updateHistory(sym.s, mid);
    
    const spreadPips = sym.spread * (0.8 + Math.random() * 0.4);
    const halfSpread = (spreadPips * sym.p) / 2;
    
    const bid = mid - halfSpread;
    const ask = mid + halfSpread;
    const change = prices[sym.s] ? (mid - prices[sym.s].mid) / sym.p : 0;
    
    prices[sym.s] = {
      bid,
      ask,
      mid,
      change,
      spread: spreadPips,
      pip: sym.p,
      type: sym.t
    };
  });
  ticks++;
}

function updateHistory(sym, price){
  if(!history[sym]) history[sym] = [];
  history[sym].push(price);
  if(history[sym].length > 50) history[sym].shift();
}

function calcRSI(sym){
  const h = history[sym];
  if(!h || h.length < C.rsiPeriod + 1) return 50;
  let gains = 0, losses = 0;
  for(let i = h.length - C.rsiPeriod; i < h.length; i++){
    const diff = h[i] - h[i-1];
    if(diff > 0) gains += diff;
    else losses -= diff;
  }
  if(losses === 0) return 100;
  const rs = gains / losses;
  return 100 - (100 / (1 + rs));
}

function calcMomentum(sym){
  const h = history[sym];
  if(!h || h.length < 10) return 0;
  return ((h[h.length-1] - h[h.length-10]) / h[h.length-10]) * 100;
}

function calcVolatility(sym){
  const h = history[sym];
  if(!h || h.length < 10) return 1;
  let sum = 0;
  for(let i = 1; i < Math.min(h.length, 10); i++){
    sum += Math.abs(h[i] - h[i-1]);
  }
  return sum / 9;
}

function getCorrelatedPairs(sym){
  const corr = {
    'EUR/USD': ['GBP/USD', 'EUR/GBP'],
    'GBP/USD': ['EUR/USD', 'EUR/GBP'],
    'USD/JPY': ['EUR/JPY', 'GBP/JPY'],
    'EUR/JPY': ['USD/JPY', 'GBP/JPY'],
    'GBP/JPY': ['USD/JPY', 'EUR/JPY'],
    'AUD/USD': ['NZD/USD', 'AUD/NZD'],
    'NZD/USD': ['AUD/USD', 'AUD/NZD'],
    'USD/CHF': ['EUR/CHF', 'EUR/USD'],
    'USD/CAD': ['AUD/CAD', 'EUR/CAD'],
    'XAU/USD': ['EUR/USD']
  };
  return corr[sym] || [];
}

// Enhanced AI Signal Generation
function getSignal(sym){
  const p = prices[sym];
  if(!p) return {score: 0, strength: 0, sig: null, rsi: 50, mom: 0};

  const rsi = calcRSI(sym);
  const mom = calcMomentum(sym);
  const vol = calcVolatility(sym);

  let score = 0, strength = 0;

  if(rsi < C.minRSI) { score += 20; strength++; }
  else if(rsi > C.maxRSI) { score -= 20; strength++; }
  else if(rsi < 40) { score += 10; }
  else if(rsi > 60) { score -= 10; }

  if(mom > 0.02 && rsi < 50) { score += 15; strength++; }
  else if(mom < -0.02 && rsi > 50) { score -= 15; strength++; }

  const h = history[sym];
  if(h && h.length >= 20){
    const ma20 = h.slice(-20).reduce((a,b) => a + b, 0) / 20;
    if(p.mid > ma20 && mom > 0) { score += 12; strength++; }
    else if(p.mid < ma20 && mom < 0) { score -= 12; strength++; }
  }

  if(vol < p.mid * 0.0005) { strength++; }

  if(sym.includes('USD')){
    const eurusd = prices['EUR/USD'];
    if(eurusd){
      if(sym.startsWith('USD') && eurusd.change < 0) { strength++; }
      else if(sym.endsWith('USD') && eurusd.change > 0) { strength++; }
    }
  }

  const corr = getCorrelatedPairs(sym);
  corr.forEach(c => {
    const cp = prices[c];
    if(cp){
      if((score > 0 && cp.change > 0) || (score < 0 && cp.change < 0)) strength++;
    }
  });

  if(p.spread > C.spreadMax) return {score, strength: 0, sig: null, rsi: Math.round(rsi), mom: mom.toFixed(3)};

  let sig = null;
  // In defensive mode, require higher strength
  const reqStrength = tradingMode === 'DEFENSIVE' ? C.minStrength + 1 : C.minStrength;
  const reqScore = tradingMode === 'DEFENSIVE' ? 30 : 25;
  
  if(score >= reqScore && strength >= reqStrength) sig = 'BUY';
  else if(score <= -reqScore && strength >= reqStrength) sig = 'SELL';

  return {score, strength, sig, rsi: Math.round(rsi), mom: mom.toFixed(3)};
}

// =====================================================
// ACCUMULATING PROFIT LOCK SYSTEM
// =====================================================

function updateProfitLock(){
  const equity = S.bal + getUnrealized();
  
  // Update session peak
  if(equity > S.sessionPeak){
    S.sessionPeak = equity;
  }
  
  // *** ACCUMULATING PROFIT LOCK ***
  // Every time equity reaches a new step level, lock more profit permanently
  const lockStep = C.profitLockStep;
  const nextLockLevel = S.lastLockLevel + lockStep;
  
  // Check if we've reached a new lock level - this can happen multiple times!
  while(equity >= S.lastLockLevel + lockStep){
    // Calculate the amount to lock for this step
    const lockAmount = lockStep * (C.profitLockPct / 100);
    
    // Add to total locked profit (ACCUMULATING - adds each time, never resets!)
    S.lockedProfit += lockAmount;
    S.lockCount++;
    S.lastLockLevel += lockStep;
    
    // Visual feedback
    flashLockStat();
    
    log(`üîí LOCK #${S.lockCount}: +$${lockAmount.toFixed(2)} ‚Üí TOTAL: $${S.lockedProfit.toFixed(2)}`, 'gold');
    
    save();
  }
  
  // Update peak for drawdown calculation
  if(S.bal > S.peak){
    S.peak = S.bal;
  }
  if(S.bal > S.best){
    S.best = S.bal;
  }
}

function flashLockStat(){
  const el = document.getElementById('lockedStat');
  el.classList.remove('lock-flash');
  void el.offsetWidth; // Trigger reflow
  el.classList.add('lock-flash');
}

function checkTradingMode(){
  const equity = S.bal + getUnrealized();
  const dailyPct = ((equity - S.dailyStartBal) / S.dailyStartBal) * 100;
  
  // Check for new day
  if(new Date().toDateString() !== dayStart){
    dayStart = new Date().toDateString();
    dailyPnL = 0;
    S.dailyStartBal = S.bal;
    // Note: We do NOT reset locked profit or lastLockLevel - they persist forever!
    tradingMode = 'NORMAL';
    log('üìÖ New trading day - mode reset (locks preserved)', 'b');
  }
  
  // LOCKED mode - daily loss limit hit
  if(dailyPct <= -C.dailyLossLimit){
    if(tradingMode !== 'LOCKED'){
      tradingMode = 'LOCKED';
      log('üîí LOCKED MODE - Daily loss limit reached', 'r');
    }
    return false;
  }
  
  // Check if equity dropped below locked profit level (minimum equity floor)
  const minEquity = C.start + S.lockedProfit;
  if(equity < minEquity && S.lockedProfit > 0){
    if(tradingMode !== 'LOCKED'){
      tradingMode = 'LOCKED';
      log(`üîí FLOOR TRIGGERED - Protecting $${S.lockedProfit.toFixed(2)} (${S.lockCount} locks)`, 'gold');
      // Close all positions to protect locked profits
      closeAllPositions('FLOOR');
    }
    return false;
  }
  
  // DEFENSIVE mode - hit daily target
  if(dailyPct >= C.dailyTarget){
    if(tradingMode === 'NORMAL'){
      tradingMode = 'DEFENSIVE';
      log(`üõ°Ô∏è DEFENSIVE MODE - ${C.dailyTarget}% target reached!`, 'gold');
    }
  }
  
  // Update mode display
  const modeEl = document.getElementById('mode');
  if(tradingMode === 'LOCKED'){
    modeEl.textContent = 'MODE:üîí';
    modeEl.className = 'badge off';
  } else if(tradingMode === 'DEFENSIVE'){
    modeEl.textContent = 'MODE:üõ°Ô∏è';
    modeEl.className = 'badge gold';
  } else {
    modeEl.textContent = 'MODE:‚ö°';
    modeEl.className = 'badge on';
  }
  
  return tradingMode !== 'LOCKED';
}

function closeAllPositions(reason){
  S.pos.forEach(pos => {
    const p = prices[pos.sym];
    if(!p) return;
    
    const isBuy = pos.type === 'BUY';
    const cur = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    const pnl = pips * pos.pipValue;
    
    S.bal += pnl;
    dailyPnL += pnl;
    
    S.returns.push(pnl / C.start * 100);
    if(S.returns.length > 100) S.returns.shift();
    
    if(pnl > 0){
      S.wins++; S.grossWin += pnl;
    } else {
      S.losses++; S.grossLoss += Math.abs(pnl);
    }
    
    sendWebhook('CLOSE', {
      ...pos,
      exitPrice: cur,
      currentPrice: cur,
      reason: reason,
      pips: pips,
      pnl: pnl
    });
    
    log(`üîí ${reason} ${pos.sym} ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`, pnl >= 0 ? 'g' : 'r');
  });
  
  S.pos = [];
  save();
}

// Check for momentum reversal exit signal
function checkMomentumExit(pos){
  const mom = calcMomentum(pos.sym);
  const rsi = calcRSI(pos.sym);
  
  // For BUY positions, exit if momentum turns strongly negative
  if(pos.type === 'BUY'){
    if(mom < -C.momentumExitThreshold) return 'MOM_REV';
    if(pos.entryRSI && rsi < pos.entryRSI - C.rsiExitBuffer) return 'RSI_REV';
  } else {
    // For SELL positions, exit if momentum turns strongly positive
    if(mom > C.momentumExitThreshold) return 'MOM_REV';
    if(pos.entryRSI && rsi > pos.entryRSI + C.rsiExitBuffer) return 'RSI_REV';
  }
  
  return null;
}

// Check for time-based exit
function checkTimeExit(pos){
  const holdTime = Date.now() - pos.time;
  
  if(holdTime > C.maxHoldTime){
    const p = prices[pos.sym];
    if(!p) return null;
    
    const isBuy = pos.type === 'BUY';
    const cur = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    
    // If position is barely moving after max hold time, close it
    if(Math.abs(pips) < C.stagnantThreshold){
      return 'TIME';
    }
  }
  
  return null;
}

// Risk Shield check
function checkRiskShield(){
  const equity = S.bal + getUnrealized();
  const dd = (S.peak - equity) / S.peak * 100;
  const heat = (S.pos.length / C.maxPos) * 100;

  document.getElementById('dd').textContent = dd.toFixed(1) + '%';
  document.getElementById('heatBar').style.width = heat + '%';
  
  // Daily P&L
  document.getElementById('todayPnl').textContent = (dailyPnL >= 0 ? '+$' : '-$') + Math.abs(dailyPnL).toFixed(2);
  document.getElementById('todayPnl').className = dailyPnL >= 0 ? 'g' : 'r';

  if(dd >= C.maxDD){
    document.getElementById('shield').textContent = 'SHIELD:üõë';
    document.getElementById('shield').className = 'badge off';
    return false;
  }

  document.getElementById('shield').textContent = 'SHIELD:‚úì';
  document.getElementById('shield').className = 'badge on';
  return true;
}

function calcLotSize(sym){
  const vol = calcVolatility(sym);
  const p = prices[sym];
  const volFactor = p ? Math.max(0.5, 1 - vol / p.mid * 100) : 1;
  const streakFactor = S.streak < -2 ? 0.5 : 1;
  // In defensive mode, use smaller lots
  const modeFactor = tradingMode === 'DEFENSIVE' ? 0.5 : 1;
  const lot = Math.max(0.01, Math.min(0.05, C.baseLot * volFactor * streakFactor * modeFactor));
  document.getElementById('lotSize').textContent = lot.toFixed(2);
  return lot;
}

function getUnrealized(){
  let u = 0;
  S.pos.forEach(pos => {
    const p = prices[pos.sym];
    if(!p) return;
    const cur = pos.type === 'BUY' ? p.bid : p.ask;
    const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
    u += pips * pos.pipValue;
  });
  return u;
}

function hasCorrelatedPosition(sym){
  const corr = getCorrelatedPairs(sym);
  return S.pos.some(p => corr.includes(p.sym) || p.sym === sym);
}

// =====================================================
// MAIN TRADING ENGINE WITH SMART EXITS
// =====================================================

function trade(){
  // Update profit lock calculations (this is where accumulation happens!)
  updateProfitLock();
  
  // Check trading mode (may block new trades)
  if(!checkTradingMode()) return;
  if(!checkRiskShield()) return;

  const now = Date.now();

  // Only open new positions in NORMAL mode, or very selectively in DEFENSIVE
  if(tradingMode === 'NORMAL' || (tradingMode === 'DEFENSIVE' && S.pos.length < 2)){
    SYM.forEach(sym => {
      const p = prices[sym.s];
      if(!p) return;

      if(lastTrade[sym.s] && now - lastTrade[sym.s] < C.cooldown) return;
      if(hasCorrelatedPosition(sym.s)) return;
      if(S.pos.length >= C.maxPos) return;

      const {sig, strength, rsi} = getSignal(sym.s);

      if(sig){
        const lot = calcLotSize(sym.s);
        const pipValue = lot * (sym.s.includes('JPY') ? 100 : 10);

        const isBuy = sig === 'BUY';
        const entry = isBuy ? p.ask : p.bid;
        const tradeId = generateTradeId();

        const newPos = {
          id: tradeId,
          sym: sym.s,
          type: sig,
          entry,
          tp: isBuy ? entry + C.tp * sym.p : entry - C.tp * sym.p,
          sl: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
          originalSL: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
          trail: null,
          trailLevel: 0,       // 0=none, 1=break-even, 2=trail1, 3=trail2, 4=trail3
          partialClosed: false,
          pipValue,
          originalPipValue: pipValue,
          pip: sym.p,
          lot,
          originalLot: lot,
          strength,
          entryRSI: rsi,
          time: now,
          maxPips: 0           // Track maximum pips reached
        };

        S.pos.push(newPos);
        sendWebhook('OPEN', newPos);
        lastTrade[sym.s] = now;
        log(`üìà ${sig} ${sym.s} @${fmtP(sym.s, entry)} [${strength}‚òÖ]`, isBuy ? 'g' : 'r');
        save();
      }
    });
  }

  managePositions();
}

function managePositions(){
  const toClose = [];

  S.pos.forEach((pos, i) => {
    const p = prices[pos.sym];
    if(!p) return;

    const isBuy = pos.type === 'BUY';
    const cur = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;

    // Track maximum pips reached
    if(pips > pos.maxPips){
      pos.maxPips = pips;
    }

    // =========================================
    // SMART TRAILING STOP SYSTEM
    // =========================================
    
    // Level 1: Break-Even Lock
    if(pips >= C.breakEvenTrigger && pos.trailLevel < 1){
      pos.trailLevel = 1;
      pos.sl = isBuy 
        ? pos.entry + C.breakEvenPlus * pos.pip 
        : pos.entry - C.breakEvenPlus * pos.pip;
      log(`üîí BE ${pos.sym} +${pips.toFixed(1)}p`, 'gold');
    }
    
    // Level 2: Trail 1 (starts at 5 pips)
    if(pips >= C.trail1Trigger && pos.trailLevel < 2){
      pos.trailLevel = 2;
      pos.trail = cur;
      log(`üìç TRAIL1 ${pos.sym} +${pips.toFixed(1)}p`, 'y');
    }
    
    // Level 3: Trail 2 (tighter at 8 pips)
    if(pips >= C.trail2Trigger && pos.trailLevel < 3){
      pos.trailLevel = 3;
      log(`üìç TRAIL2 ${pos.sym} +${pips.toFixed(1)}p`, 'y');
    }
    
    // Level 4: Trail 3 (very tight at 12 pips)
    if(pips >= C.trail3Trigger && pos.trailLevel < 4){
      pos.trailLevel = 4;
      log(`üìç TRAIL3 ${pos.sym} +${pips.toFixed(1)}p`, 'g');
    }

    // Update trailing stop based on current level
    if(pos.trailLevel >= 2 && pos.trail){
      let trailDist;
      if(pos.trailLevel === 4) trailDist = C.trail3Distance;
      else if(pos.trailLevel === 3) trailDist = C.trail2Distance;
      else trailDist = C.trail1Distance;
      
      if(isBuy && cur > pos.trail){
        pos.trail = cur;
        pos.sl = cur - trailDist * pos.pip;
      } else if(!isBuy && cur < pos.trail){
        pos.trail = cur;
        pos.sl = cur + trailDist * pos.pip;
      }
    }

    // =========================================
    // PARTIAL PROFIT TAKING
    // =========================================
    if(pips >= C.partial1Trigger && !pos.partialClosed){
      pos.partialClosed = true;
      const partialPnL = pips * pos.pipValue * C.partial1Pct;
      S.bal += partialPnL;
      dailyPnL += partialPnL;
      
      // Reduce position size
      pos.lot = pos.originalLot * (1 - C.partial1Pct);
      pos.pipValue = pos.originalPipValue * (1 - C.partial1Pct);
      
      S.grossWin += partialPnL;
      log(`üí∞ PARTIAL ${pos.sym} +$${partialPnL.toFixed(2)} (50% closed)`, 'gold');
    }

    // =========================================
    // EXIT SIGNAL CHECKS
    // =========================================
    let reason = null;
    
    // Check TP/SL first
    if(isBuy){
      if(cur >= pos.tp) reason = 'TP';
      else if(cur <= pos.sl) reason = pos.trailLevel > 1 ? 'TRAIL' : (pos.trailLevel === 1 ? 'BE' : 'SL');
    } else {
      if(cur <= pos.tp) reason = 'TP';
      else if(cur >= pos.sl) reason = pos.trailLevel > 1 ? 'TRAIL' : (pos.trailLevel === 1 ? 'BE' : 'SL');
    }
    
    // Check momentum exit (only if in profit and not already exiting)
    if(!reason && pips > 2){
      const momExit = checkMomentumExit(pos);
      if(momExit) reason = momExit;
    }
    
    // Check time-based exit
    if(!reason){
      const timeExit = checkTimeExit(pos);
      if(timeExit) reason = timeExit;
    }

    // =========================================
    // CLOSE POSITION
    // =========================================
    if(reason){
      // Calculate remaining position P&L (after partial close)
      const remainingPips = pips;
      const pnl = remainingPips * pos.pipValue;
      S.bal += pnl;
      dailyPnL += pnl;

      S.returns.push((pnl + (pos.partialClosed ? C.partial1Trigger * pos.originalPipValue * C.partial1Pct : 0)) / C.start * 100);
      if(S.returns.length > 100) S.returns.shift();

      const totalPnL = pnl + (pos.partialClosed ? C.partial1Trigger * pos.originalPipValue * C.partial1Pct : 0);
      
      if(totalPnL > 0){
        S.wins++; S.grossWin += pnl;
        S.streak = S.streak > 0 ? S.streak + 1 : 1;
      } else {
        S.losses++; S.grossLoss += Math.abs(pnl);
        S.streak = S.streak < 0 ? S.streak - 1 : -1;
      }

      sendWebhook('CLOSE', {
        ...pos,
        exitPrice: cur,
        currentPrice: cur,
        reason: reason,
        pips: remainingPips,
        pnl: pnl
      });

      const em = reason === 'TP' ? '‚úÖ' : reason === 'TRAIL' ? 'üìà' : reason === 'BE' ? 'üîí' : reason === 'MOM_REV' ? '‚Ü©Ô∏è' : reason === 'RSI_REV' ? 'üìä' : reason === 'TIME' ? '‚è∞' : '‚ùå';
      log(`${em} ${reason} ${pos.sym} ${totalPnL >= 0 ? '+' : ''}$${totalPnL.toFixed(2)}`, totalPnL >= 0 ? 'g' : 'r');
      toClose.push(i);
    }
  });

  if(toClose.length){
    S.pos = S.pos.filter((_, i) => !toClose.includes(i));
    save();
  }
}

function calcSharpe(){
  if(S.returns.length < 10) return 0;
  const mean = S.returns.reduce((a, b) => a + b, 0) / S.returns.length;
  const variance = S.returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / S.returns.length;
  const std = Math.sqrt(variance);
  return std === 0 ? 0 : (mean / std * Math.sqrt(252)).toFixed(2);
}

function log(msg, cls){
  logs.unshift({msg, cls, t: Date.now()});
  if(logs.length > 20) logs.pop();
}

function fmtP(sym, price){
  const s = SYM.find(x => x.s === sym);
  if(!s) return price.toFixed(4);
  if(s.p >= 0.01) return price.toFixed(2);
  return price.toFixed(5);
}

function render(){
  const unr = getUnrealized();
  const equity = S.bal + unr;
  const pnl = equity - C.start;
  const pct = (pnl / C.start) * 100;
  const total = S.wins + S.losses;
  const wr = total > 0 ? Math.round(S.wins / total * 100) : 0;
  const pf = S.grossLoss > 0 ? (S.grossWin / S.grossLoss).toFixed(2) : '‚àû';

  // Main stats
  document.getElementById('equity').textContent = '$' + equity.toFixed(2);
  document.getElementById('equity').className = pnl >= 0 ? 'g' : 'r';
  document.getElementById('pnlPct').textContent = (pnl >= 0 ? '+' : '') + pct.toFixed(2) + '%';
  document.getElementById('pnlPct').className = pnl >= 0 ? 'g' : 'r';
  
  // Locked profit display (accumulating)
  document.getElementById('locked').textContent = '$' + S.lockedProfit.toFixed(2);
  document.getElementById('lockPct').textContent = S.lockCount + ' locks';
  document.getElementById('lockCount').textContent = S.lockCount;
  
  // Next lock level
  const nextLockAt = S.lastLockLevel + C.profitLockStep;
  document.getElementById('nextLockAt').textContent = '$' + nextLockAt.toFixed(2);
  
  // Progress to next lock
  const progressToNextLock = Math.max(0, Math.min(100, ((equity - S.lastLockLevel) / C.profitLockStep) * 100));
  document.getElementById('lockBar').style.width = progressToNextLock + '%';
  
  document.getElementById('trades').textContent = total;
  document.getElementById('winrate').textContent = wr + '%';
  document.getElementById('winrate').className = wr >= 50 ? 'g' : wr >= 40 ? 'y' : 'r';
  document.getElementById('pf').textContent = pf;
  document.getElementById('openPos').textContent = S.pos.length + '/' + C.maxPos;
  document.getElementById('streak').textContent = (S.streak > 0 ? '+' : '') + S.streak;
  document.getElementById('streak').className = S.streak > 0 ? 'g' : S.streak < 0 ? 'r' : '';
  document.getElementById('best').textContent = '$' + S.best.toFixed(2);
  document.getElementById('avgWin').textContent = '$' + (S.wins > 0 ? (S.grossWin / S.wins).toFixed(2) : '0');
  document.getElementById('sharpe').textContent = calcSharpe();
  document.getElementById('time').textContent = new Date().toLocaleTimeString();
  document.getElementById('status').textContent = 'üü¢ LIVE';
  document.getElementById('status').className = 'badge on';

  // Progress bars
  const dailyPct = ((equity - S.dailyStartBal) / S.dailyStartBal) * 100;
  const targetProgress = Math.min(100, Math.max(0, (dailyPct / C.dailyTarget) * 100));
  document.getElementById('targetBar').style.width = targetProgress + '%';
  document.getElementById('targetBar').style.background = dailyPct >= C.dailyTarget ? 'var(--gold)' : 'var(--g)';

  // Market table
  document.getElementById('market').innerHTML = SYM.map(sym => {
    const p = prices[sym.s];
    if(!p) return '';
    const {strength, sig, rsi, mom} = getSignal(sym.s);
    const pos = S.pos.find(x => x.sym === sym.s);

    let posH = '-';
    if(pos){
      const cur = pos.type === 'BUY' ? p.bid : p.ask;
      const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
      const posPnl = pips * pos.pipValue;
      const trailIcon = pos.trailLevel >= 2 ? 'üìà' : pos.trailLevel === 1 ? 'üîí' : '';
      posH = `<span class="${posPnl >= 0 ? 'g' : 'r'}">${trailIcon}${posPnl >= 0 ? '+' : ''}$${posPnl.toFixed(2)}</span>`;
    }

    let sigH = '-';
    if(sig === 'BUY') sigH = '<span class="g">‚ñ≤BUY</span>';
    else if(sig === 'SELL') sigH = '<span class="r">‚ñºSELL</span>';

    const rsiC = rsi < 30 ? 'g' : rsi > 70 ? 'r' : 'dim';
    const momC = parseFloat(mom) > 0 ? 'g' : parseFloat(mom) < 0 ? 'r' : 'dim';
    const typeC = sym.t === 'major' ? 'b' : sym.t === 'metal' ? 'y' : 'dim';

    return `<tr>
      <td><b class="${typeC}">${sym.s}</b></td>
      <td>${fmtP(sym.s, p.bid)}</td>
      <td>${fmtP(sym.s, p.ask)}</td>
      <td class="dim">${p.spread.toFixed(1)}</td>
      <td class="${rsiC}">${rsi}</td>
      <td class="${momC}">${mom}</td>
      <td>${sigH}</td>
      <td>${posH}</td>
    </tr>`;
  }).join('');

  // Positions
  if(S.pos.length === 0){
    document.getElementById('positions').innerHTML = '<span class="dim">Scanning markets...</span>';
  } else {
    document.getElementById('positions').innerHTML = S.pos.map(pos => {
      const p = prices[pos.sym];
      if(!p) return '';
      const cur = pos.type === 'BUY' ? p.bid : p.ask;
      const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
      const posPnl = pips * pos.pipValue;
      const trailIcon = pos.trailLevel >= 2 ? 'üìà' : pos.trailLevel === 1 ? 'üîí' : '';
      const partialIcon = pos.partialClosed ? 'üí∞' : '';
      return `<div class="log" style="border-left:2px solid ${posPnl >= 0 ? 'var(--g)' : 'var(--r)'}">
        ${trailIcon}${partialIcon} ${pos.sym} <span class="${pos.type === 'BUY' ? 'g' : 'r'}">${pos.type}</span>
        <span class="${posPnl >= 0 ? 'g' : 'r'}">${pips >= 0 ? '+' : ''}${pips.toFixed(1)}p ($${posPnl.toFixed(2)})</span>
      </div>`;
    }).join('');
  }

  // Log
  document.getElementById('log').innerHTML = logs.length
    ? logs.slice(0, 12).map(l => `<div class="log ${l.cls}">${l.msg}</div>`).join('')
    : '<span class="dim">Starting...</span>';

  // Chart
  S.eq.push(equity);
  if(S.eq.length > 60) S.eq.shift();
  const min = Math.min(...S.eq) * 0.98;
  const max = Math.max(...S.eq) * 1.02;
  const range = max - min || 1;
  document.getElementById('chart').innerHTML = S.eq.map((v, i) => {
    const h = Math.max(4, ((v - min) / range) * 100);
    const c = v >= C.start ? 'var(--g)' : 'var(--r)';
    const o = 0.3 + (i / S.eq.length) * 0.7;
    return `<div style="height:${h}%;background:${c};opacity:${o}"></div>`;
  }).join('');
}

// Init
async function init(){
  loadWebhookConfig();
  log('üöÄ HFT ULTRA FX SMART LOCK 2026 Starting...', 'b');
  log('üì° Fetching ECB forex rates...', 'b');

  // Update config displays
  document.getElementById('beTrigger').textContent = C.breakEvenTrigger + 'p';
  document.getElementById('trailStart').textContent = C.trail1Trigger + 'p';
  document.getElementById('lockPctStat').textContent = C.profitLockPct + '%';
  document.getElementById('lockStep').textContent = '$' + C.profitLockStep;

  const ok = await fetchECBRates();
  if(ok){
    updatePrices();
    render();
    log('‚úÖ Ready! 28 forex pairs loaded', 'g');
    log(`üîí Accumulating Profit Lock: $${C.profitLockStep} steps, ${C.profitLockPct}% locked`, 'gold');
    if(S.lockCount > 0){
      log(`üìä Restored: ${S.lockCount} locks, $${S.lockedProfit.toFixed(2)} protected`, 'gold');
    }
    if(webhookConfig.url){
      log('üîó MT5 Webhook ENABLED', 'b');
    }
  } else {
    log('‚ùå Failed to fetch rates', 'r');
  }

  // Refresh ECB rates every 5 minutes
  setInterval(fetchECBRates, 300000);

  // Main loop - simulate ticks every 1 second
  setInterval(() => {
    updatePrices();
    trade();
    render();
  }, 1000);

  setInterval(save, 5000);
}

init();
</script>
</body>
</html>
