<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>FOREX ULTRA 2026 - Telegram Bridge</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0e14;--card:#121820;--border:#1a2030;--txt:#c8d0dc;--dim:#5a6270;--g:#0f6;--r:#f44;--b:#0af;--y:#fc0}
html.light{--bg:#f4f6f8;--card:#fff;--border:#dde;--txt:#1a1a2e;--dim:#888}
body{background:var(--bg);color:var(--txt);font:11px/1.4 monospace;padding:8px;min-height:100vh}
.g{color:var(--g)}.r{color:var(--r)}.b{color:var(--b)}.y{color:var(--y)}.dim{color:var(--dim)}
.card{background:var(--card);border:1px solid var(--border);border-radius:4px;padding:8px;margin-bottom:8px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.col{flex:1;min-width:120px}
.grid{display:grid;gap:4px}
.g2{grid-template-columns:repeat(2,1fr)}.g3{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(4,1fr)}.g6{grid-template-columns:repeat(6,1fr)}
.stat{background:var(--bg);padding:6px;border-radius:3px;text-align:center}
.stat small{display:block;font-size:9px;color:var(--dim);margin-bottom:2px}
.stat b{font-size:13px}
h1{font-size:14px;margin-bottom:4px}
table{width:100%;border-collapse:collapse;font-size:10px}
th,td{padding:4px;text-align:right}
th{color:var(--dim);font-weight:400;border-bottom:1px solid var(--border)}
td:first-child,th:first-child{text-align:left}
tr:hover{background:rgba(255,255,255,.02)}
.scroll{max-height:200px;overflow-y:auto}
.bar{height:40px;display:flex;align-items:end;gap:1px}
.bar div{flex:1;min-width:2px;border-radius:1px 1px 0 0}
.log{font-size:9px;padding:2px 4px;margin:1px 0;border-radius:2px;background:var(--bg)}
button{background:var(--card);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;cursor:pointer;font:inherit}
button:hover{background:var(--border)}
.pulse{animation:p 1.5s infinite}@keyframes p{50%{opacity:.5}}
.badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px}
.badge.on{background:#0f62;color:var(--g)}.badge.off{background:#f442;color:var(--r)}.badge.warn{background:#fc02;color:var(--y)}
input[type="text"]{background:var(--bg);border:1px solid var(--border);color:var(--txt);padding:4px 8px;border-radius:3px;font:inherit;width:100%;font-size:16px}
input[type="text"]:focus{outline:none;border-color:var(--b)}
.webhook-status{font-size:9px;margin-top:4px}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:400px;width:90%}
.modal h3{margin-bottom:12px;font-size:14px}
.modal-buttons{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
@media(max-width:600px){.g6{grid-template-columns:repeat(3,1fr)}.g4{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>
<div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
<div>
<h1>‚ö° FOREX ULTRA <span class="dim">2026</span> <span class="y">[TELEGRAM BRIDGE]</span></h1>
<small class="dim">28 FX PAIRS ‚Ä¢ REAL FOREX DATA ‚Ä¢ TELEGRAM ‚Üí MT5 BRIDGE ‚Ä¢ ECB SIGNALS</small>
</div>
<div class="row" style="gap:4px">
<span id="status" class="badge pulse">INIT</span>
<span id="api" class="badge dim">API:--</span>
<span id="telegramStatus" class="badge dim">TG:--</span>
<span id="shield" class="badge">SHIELD:--</span>
<button onclick="showTelegramConfig()">‚öôÔ∏è</button>
<button onclick="reset()">‚ü≤</button>
</div>
</div>

<div class="grid g6" style="margin-bottom:8px">
<div class="stat"><small>üí∞ EQUITY</small><b id="equity" class="g">$100.00</b><div id="pnlPct" style="font-size:9px">+0.00%</div></div>
<div class="stat"><small>P&L</small><b id="pnl">$0.00</b></div>
<div class="stat"><small>TRADES</small><b id="trades" class="b">0</b></div>
<div class="stat"><small>WIN%</small><b id="winrate" class="y">0%</b></div>
<div class="stat"><small>PROFIT F.</small><b id="pf" class="g">0.00</b></div>
<div class="stat"><small>OPEN</small><b id="openPos" class="b">0/6</b></div>
<div class="stat"><small>STREAK</small><b id="streak">0</b></div>
<div class="stat"><small>BEST</small><b id="best" class="g">$100</b></div>
<div class="stat"><small>DD</small><b id="dd" class="r">0%</b></div>
<div class="stat"><small>AVG WIN</small><b id="avgWin" class="g">$0</b></div>
<div class="stat"><small>AVG LOSS</small><b id="avgLoss" class="r">$0</b></div>
<div class="stat"><small>SIGNALS SENT</small><b id="signalsSent" class="b">0</b></div>
</div>

<div class="row">
<div class="col" style="flex:3">
<div class="card">
<div class="row" style="justify-content:space-between;margin-bottom:4px">
<b class="b">üìä FOREX MARKET</b>
<span id="time" class="dim">--:--:--</span>
</div>
<div class="scroll"><table><thead><tr><th>SYM</th><th>BID</th><th>ASK</th><th>Œî</th><th>RSI</th><th>MOM</th><th>ECB BIAS</th><th>SIG</th><th>P&L</th></tr></thead><tbody id="market"></tbody></table></div>
</div>
</div>
<div class="col">
<div class="card">
<b>üìà POSITIONS</b>
<div id="positions" class="scroll" style="margin-top:4px"><span class="dim">Scanning...</span></div>
</div>
<div class="card">
<b>‚ö° LOG</b>
<div id="log" class="scroll" style="margin-top:4px"><span class="dim">Starting...</span></div>
</div>
</div>
</div>

<div class="row">
<div class="col">
<div class="card"><b>üíπ EQUITY</b><div class="bar" id="chart"></div></div>
</div>
<div class="col">
<div class="card">
<b>ü§ñ TELEGRAM BRIDGE</b>
<div class="grid g3" style="margin-top:6px;font-size:9px;text-align:center">
<div class="stat"><small>BOT STATUS</small><span id="botStatus" class="y">OFFLINE</span></div>
<div class="stat"><small>SIGNALS TODAY</small><span id="signalsToday">0</span></div>
<div class="stat"><small>CHAT ID</small><span id="chatIdDisplay">--</span></div>
<div class="stat"><small>LAST SIGNAL</small><span id="lastSignalTime">--:--</span></div>
<div class="stat"><small>SUCCESS RATE</small><span id="successRate" class="g">100%</span></div>
<div class="stat"><small>LOT SIZE</small><span id="lotSize" class="b">0.01</span></div>
</div>
</div>
</div>
</div>

<!-- Telegram Config Modal -->
<div id="telegramModal" class="modal-overlay" style="display:none">
<div class="modal">
<h3>ü§ñ TELEGRAM BRIDGE CONFIGURATION</h3>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">1. Telegram Bot Token</label>
<input type="text" id="telegramToken" placeholder="1234567890:ABCdefGHIjklMNopQRstuVWXyz" value="8488789199:AAHhViKmhXlve7WpgZGvDS4wjCju">
<small class="dim">Get from @BotFather on Telegram</small>
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">2. Your Chat ID</label>
<input type="text" id="telegramChatId" placeholder="123456789" value="93372553">
<small class="dim">Send /start to @userinfobot to get your ID</small>
</div>
<div style="margin-bottom:12px">
<label class="dim" style="display:block;margin-bottom:4px">3. MT5 EA Webhook URL</label>
<input type="text" id="mt5WebhookUrl" placeholder="http://192.168.1.100:24843/webhook" value="https://docker-metatrader-production.up.railway.app/">
<small class="dim">Your MT5 Expert Advisor endpoint (TelegramToMT5 EA)</small>
</div>
<div class="grid g2" style="margin-bottom:12px">
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgSignalEnabled" checked> Send Trading Signals
</label>
<label style="display:flex;align-items:center;gap:4px;cursor:pointer">
<input type="checkbox" id="tgAlertEnabled" checked> Send Alerts
</label>
</div>
<div class="webhook-status" id="telegramTestResult"></div>
<div class="modal-buttons">
<button onclick="testTelegramConnection()">üß™ Test Telegram</button>
<button onclick="testMT5Connection()">üîó Test MT5</button>
<button onclick="saveTelegramConfig()">üíæ Save</button>
<button onclick="closeTelegramModal()">‚úï Close</button>
</div>
</div>
</div>

<script>
// =====================================================
// TELEGRAM BRIDGE CONFIGURATION
// =====================================================
const telegramConfig = {
    botToken: '8488789199:AAHhViKmhXlve7WpgZGvDS4wjCju',
    chatId: '93372553',
    mt5WebhookUrl: 'https://docker-metatrader-production.up.railway.app/',
    signalEnabled: true,
    alertEnabled: true,
    signalsSent: 0,
    signalsToday: 0,
    lastSignalTime: null,
    successCount: 0,
    errorCount: 0
};

// =====================================================
// FOREX INSTRUMENTS (28 pairs + XAUUSD)
// =====================================================
const SYM = [
    // Major Pairs
    {s:'EUR/USD', b:'EURUSD', p:0.00001, t:'major', mt5:'EURUSD', pipFactor:10000},
    {s:'GBP/USD', b:'GBPUSD', p:0.00001, t:'major', mt5:'GBPUSD', pipFactor:10000},
    {s:'USD/JPY', b:'USDJPY', p:0.001, t:'major', mt5:'USDJPY', pipFactor:100},
    {s:'USD/CHF', b:'USDCHF', p:0.00001, t:'major', mt5:'USDCHF', pipFactor:10000},
    {s:'AUD/USD', b:'AUDUSD', p:0.00001, t:'major', mt5:'AUDUSD', pipFactor:10000},
    {s:'USD/CAD', b:'USDCAD', p:0.00001, t:'major', mt5:'USDCAD', pipFactor:10000},
    {s:'NZD/USD', b:'NZDUSD', p:0.00001, t:'major', mt5:'NZDUSD', pipFactor:10000},
    
    // Crosses
    {s:'EUR/GBP', b:'EURGBP', p:0.00001, t:'cross', mt5:'EURGBP', pipFactor:10000},
    {s:'EUR/JPY', b:'EURJPY', p:0.001, t:'cross', mt5:'EURJPY', pipFactor:100},
    {s:'GBP/JPY', b:'GBPJPY', p:0.001, t:'cross', mt5:'GBPJPY', pipFactor:100},
    {s:'EUR/CHF', b:'EURCHF', p:0.00001, t:'cross', mt5:'EURCHF', pipFactor:10000},
    {s:'EUR/AUD', b:'EURAUD', p:0.00001, t:'cross', mt5:'EURAUD', pipFactor:10000},
    {s:'EUR/CAD', b:'EURCAD', p:0.00001, t:'cross', mt5:'EURCAD', pipFactor:10000},
    {s:'GBP/AUD', b:'GBPAUD', p:0.00001, t:'cross', mt5:'GBPAUD', pipFactor:10000},
    {s:'GBP/CAD', b:'GBPCAD', p:0.00001, t:'cross', mt5:'GBPCAD', pipFactor:10000},
    {s:'AUD/JPY', b:'AUDJPY', p:0.001, t:'cross', mt5:'AUDJPY', pipFactor:100},
    {s:'CAD/JPY', b:'CADJPY', p:0.001, t:'cross', mt5:'CADJPY', pipFactor:100},
    {s:'NZD/JPY', b:'NZDJPY', p:0.001, t:'cross', mt5:'NZDJPY', pipFactor:100},
    {s:'AUD/CAD', b:'AUDCAD', p:0.00001, t:'cross', mt5:'AUDCAD', pipFactor:10000},
    {s:'AUD/NZD', b:'AUDNZD', p:0.00001, t:'cross', mt5:'AUDNZD', pipFactor:10000},
    {s:'CAD/CHF', b:'CADCHF', p:0.00001, t:'cross', mt5:'CADCHF', pipFactor:10000},
    {s:'CHF/JPY', b:'CHFJPY', p:0.001, t:'cross', mt5:'CHFJPY', pipFactor:100},
    
    // Commodities
    {s:'XAU/USD', b:'XAUUSD', p:0.01, t:'commodity', mt5:'XAUUSD', pipFactor:100},
    {s:'XAG/USD', b:'XAGUSD', p:0.0001, t:'commodity', mt5:'XAGUSD', pipFactor:10000},
    
    // Exotics
    {s:'USD/SGD', b:'USDSGD', p:0.00001, t:'exotic', mt5:'USDSGD', pipFactor:10000},
    {s:'USD/HKD', b:'USDHKD', p:0.00001, t:'exotic', mt5:'USDHKD', pipFactor:10000},
    {s:'USD/MXN', b:'USDMXN', p:0.0001, t:'exotic', mt5:'USDMXN', pipFactor:1000},
    {s:'USD/TRY', b:'USDTRY', p:0.0001, t:'exotic', mt5:'USDTRY', pipFactor:1000}
];

// ECB Interest Rates and Central Bank Bias
const ECB_BIAS = {
    'EUR': {rate: 4.0, bias: 'hawkish', lastMeeting: '2024-01-25'},
    'USD': {rate: 5.5, bias: 'hawkish', lastMeeting: '2024-01-31'},
    'GBP': {rate: 5.25, bias: 'hawkish', lastMeeting: '2024-02-01'},
    'JPY': {rate: -0.1, bias: 'dovish', lastMeeting: '2024-01-23'},
    'CHF': {rate: 1.75, bias: 'neutral', lastMeeting: '2024-12-14'},
    'CAD': {rate: 5.0, bias: 'neutral', lastMeeting: '2024-01-24'},
    'AUD': {rate: 4.35, bias: 'neutral', lastMeeting: '2024-02-06'},
    'NZD': {rate: 5.5, bias: 'hawkish', lastMeeting: '2024-02-28'}
};

// =====================================================
// TRADING CONFIGURATION
// =====================================================
const C = {
    start: 100,
    baseLot: 0.01,
    tp: 20,           // 20 pip TP
    sl: 10,           // 10 pip SL
    trail: 8,         // Trail after 8 pips
    maxPos: 6,
    maxDD: 5,
    dailyLossLimit: 3,
    cooldown: 5000,
    rsiPeriod: 14,
    minRSI: 25,
    maxRSI: 75,
    minStrength: 3,
    spreadMax: 2,
    corrThreshold: 0.7,
    // Economic calendar filter
    newsImpact: ['high', 'medium'],  // Only trade high/medium impact news
    newsCooldown: 3600000,  // 1 hour before/after major news
    // ECB data refresh
    ecbRefresh: 300000  // 5 minutes
};

// =====================================================
// TELEGRAM BRIDGE FUNCTIONS
// =====================================================
function loadTelegramConfig() {
    try {
        const hash = location.hash.slice(1);
        if (hash) {
            const data = JSON.parse(atob(hash));
            if (data.telegramConfig) {
                Object.assign(telegramConfig, data.telegramConfig);
            }
        }
    } catch (e) {
        console.log('No Telegram config found');
    }
    updateTelegramUI();
}

function saveTelegramConfig() {
    telegramConfig.botToken = document.getElementById('telegramToken').value.trim();
    telegramConfig.chatId = document.getElementById('telegramChatId').value.trim();
    telegramConfig.mt5WebhookUrl = document.getElementById('mt5WebhookUrl').value.trim();
    telegramConfig.signalEnabled = document.getElementById('tgSignalEnabled').checked;
    telegramConfig.alertEnabled = document.getElementById('tgAlertEnabled').checked;
    
    save(); // Save to URL hash
    updateTelegramUI();
    closeTelegramModal();
    log('ü§ñ Telegram config saved', 'b');
}

function showTelegramConfig() {
    document.getElementById('telegramToken').value = telegramConfig.botToken;
    document.getElementById('telegramChatId').value = telegramConfig.chatId;
    document.getElementById('mt5WebhookUrl').value = telegramConfig.mt5WebhookUrl;
    document.getElementById('tgSignalEnabled').checked = telegramConfig.signalEnabled;
    document.getElementById('tgAlertEnabled').checked = telegramConfig.alertEnabled;
    document.getElementById('telegramModal').style.display = 'flex';
}

function closeTelegramModal() {
    document.getElementById('telegramModal').style.display = 'none';
}

async function testTelegramConnection() {
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    const resultEl = document.getElementById('telegramTestResult');
    
    if (!token || !chatId) {
        resultEl.innerHTML = '<span class="r">‚ùå Enter Token & Chat ID</span>';
        return;
    }
    
    resultEl.innerHTML = '<span class="y">üîÑ Testing Telegram connection...</span>';
    
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
        const data = await response.json();
        
        if (data.ok) {
            resultEl.innerHTML = `<span class="g">‚úÖ Bot connected: ${data.result.username}</span>`;
            
            // Send test message
            setTimeout(async () => {
                try {
                    await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            chat_id: chatId,
                            text: '‚úÖ FOREX ULTRA 2026 Telegram Bridge Connected!\nSystem ready to forward ECB-based signals to MT5.'
                        })
                    });
                    log('‚úÖ Telegram test successful', 'g');
                } catch (msgErr) {
                    log(`‚ö†Ô∏è Could not send test message: ${msgErr.message}`, 'y');
                }
            }, 500);
        } else {
            resultEl.innerHTML = `<span class="r">‚ùå Invalid bot token</span>`;
        }
    } catch (err) {
        resultEl.innerHTML = `<span class="r">‚ùå Connection failed: ${err.message}</span>`;
    }
}

async function testMT5Connection() {
    const mt5Url = document.getElementById('mt5WebhookUrl').value.trim();
    const resultEl = document.getElementById('telegramTestResult');
    
    if (!mt5Url) {
        resultEl.innerHTML = '<span class="r">‚ùå Enter MT5 Webhook URL</span>';
        return;
    }
    
    resultEl.innerHTML = '<span class="y">üîÑ Testing MT5 connection...</span>';
    
    // Format signal for TelegramToMT5 EA
    const testSignal = {
        action: 'OPEN',
        symbol: 'EURUSD',
        type: 'BUY',  // BUY or SELL
        price: 1.0850,
        lot: 0.01,
        sl: 1.0840,
        tp: 1.0870,
        comment: 'TG-TEST-' + Date.now(),
        magic: 2026,
        timestamp: new Date().toISOString(),
        source: 'FOREX-TELEGRAM-BRIDGE-TEST'
    };
    
    try {
        const response = await fetch(mt5Url, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testSignal)
        });
        
        if (response.ok) {
            resultEl.innerHTML = '<span class="g">‚úÖ MT5 connection successful</span>';
            log('‚úÖ MT5 test signal sent', 'g');
        } else {
            resultEl.innerHTML = '<span class="r">‚ùå MT5 responded with error</span>';
            log(`‚ö†Ô∏è MT5 test failed: ${response.status}`, 'y');
        }
    } catch (err) {
        resultEl.innerHTML = `<span class="r">‚ùå MT5 connection failed: ${err.message}</span>`;
        log(`‚ö†Ô∏è MT5 test failed: ${err.message}`, 'y');
    }
}

function updateTelegramUI() {
    const el = document.getElementById('telegramStatus');
    if (telegramConfig.botToken && telegramConfig.chatId) {
        el.textContent = 'TG:‚úì';
        el.className = 'badge on';
        document.getElementById('botStatus').textContent = 'ONLINE';
        document.getElementById('botStatus').className = 'g';
        document.getElementById('chatIdDisplay').textContent = telegramConfig.chatId.substring(0, 6) + '...';
    } else {
        el.textContent = 'TG:OFF';
        el.className = 'badge dim';
        document.getElementById('botStatus').textContent = 'OFFLINE';
        document.getElementById('botStatus').className = 'r';
    }
    
    document.getElementById('signalsSent').textContent = telegramConfig.signalsSent;
    document.getElementById('signalsToday').textContent = telegramConfig.signalsToday;
    document.getElementById('lastSignalTime').textContent = telegramConfig.lastSignalTime ? 
        telegramConfig.lastSignalTime.substring(11, 16) : '--:--';
    
    const total = telegramConfig.successCount + telegramConfig.errorCount;
    document.getElementById('successRate').textContent = total > 0 ? 
        Math.round((telegramConfig.successCount / total) * 100) + '%' : '100%';
}

// =====================================================
// SIGNAL FORWARDING SYSTEM (TelegramToMT5 EA Format)
// =====================================================
async function forwardSignalToTelegram(signalData) {
    if (!telegramConfig.signalEnabled || !telegramConfig.botToken || !telegramConfig.chatId) {
        return false;
    }
    
    // Format message for Telegram
    let message = '';
    if (signalData.action === 'OPEN') {
        const baseCurrency = signalData.symbol.substring(0, 3);
        const quoteCurrency = signalData.symbol.substring(3, 6);
        const baseBias = ECB_BIAS[baseCurrency] ? ECB_BIAS[baseCurrency].bias : 'neutral';
        const quoteBias = ECB_BIAS[quoteCurrency] ? ECB_BIAS[quoteCurrency].bias : 'neutral';
        
        message = `üöÄ <b>${signalData.type} ${signalData.symbol}</b>\n`;
        message += `üí∞ Entry: <code>${signalData.entry_price.toFixed(5)}</code>\n`;
        message += `üéØ TP: <code>${signalData.take_profit.toFixed(5)}</code> (${C.tp} pips)\n`;
        message += `üõë SL: <code>${signalData.stop_loss.toFixed(5)}</code> (${C.sl} pips)\n`;
        message += `üìä Lot: <code>${signalData.lot_size}</code>\n`;
        message += `‚ö° Strength: ${signalData.signal_strength}/5\n`;
        message += `üè¶ ECB Bias: ${baseBias.toUpperCase()} vs ${quoteBias.toUpperCase()}\n`;
        message += `üÜî ${signalData.trade_id}\n`;
        message += `üïí ${new Date(signalData.timestamp).toLocaleTimeString()}`;
    } else {
        message = `üèÅ <b>${signalData.symbol} CLOSED</b>\n`;
        message += `üìä Result: <b>${signalData.exit_reason}</b>\n`;
        message += `üí∞ P&L: <code>$${signalData.pnl_usd.toFixed(2)}</code>\n`;
        message += `üìà Pips: <code>${signalData.pnl_pips.toFixed(1)}</code>\n`;
        message += `‚è±Ô∏è Duration: ${Math.round(signalData.duration_ms / 1000)}s\n`;
        message += `üÜî ${signalData.trade_id}\n`;
        message += `üïí ${new Date(signalData.timestamp).toLocaleTimeString()}`;
    }
    
    try {
        // Send to Telegram
        const tgResponse = await fetch(`https://api.telegram.org/bot${telegramConfig.botToken}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: telegramConfig.chatId,
                text: message,
                parse_mode: 'HTML',
                disable_web_page_preview: true
            })
        });
        
        if (tgResponse.ok) {
            telegramConfig.signalsSent++;
            telegramConfig.signalsToday++;
            telegramConfig.lastSignalTime = new Date().toISOString();
            telegramConfig.successCount++;
            
            // Update UI
            updateTelegramUI();
            
            log(`üì± Telegram signal sent: ${signalData.symbol}`, 'b');
            
            // Forward to MT5 if URL is set
            if (telegramConfig.mt5WebhookUrl) {
                setTimeout(() => forwardSignalToMT5(signalData), 100);
            }
            
            return true;
        }
    } catch (err) {
        telegramConfig.errorCount++;
        log(`‚ö†Ô∏è Telegram error: ${err.message}`, 'y');
    }
    
    return false;
}

async function forwardSignalToMT5(signalData) {
    if (!telegramConfig.mt5WebhookUrl) return false;
    
    try {
        // Convert signal to TelegramToMT5 EA format
        const mt5Signal = {
            action: signalData.action === 'OPEN' ? 'OPEN' : 'CLOSE',
            symbol: signalData.symbol,
            type: signalData.direction === 'BUY' ? 'BUY' : 'SELL',
            price: signalData.entry_price || signalData.exit_price,
            lot: signalData.lot_size,
            sl: signalData.stop_loss,
            tp: signalData.take_profit,
            comment: `TG-${signalData.trade_id}`,
            magic: 2026,
            timestamp: signalData.timestamp,
            source: 'FOREX-TELEGRAM-BRIDGE',
            // Additional fields for TelegramToMT5 EA
            ticket: 0,  // 0 for new orders
            slippage: 3,
            deviation: 10
        };
        
        const response = await fetch(telegramConfig.mt5WebhookUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(mt5Signal)
        });
        
        if (response.ok) {
            log(`üîó Signal forwarded to MT5: ${signalData.symbol}`, 'g');
            return true;
        } else {
            log(`‚ö†Ô∏è MT5 responded with error: ${response.status}`, 'y');
            return false;
        }
    } catch (err) {
        log(`‚ö†Ô∏è MT5 forward failed: ${err.message}`, 'y');
        return false;
    }
}

async function sendAlert(message, type = 'info') {
    if (!telegramConfig.alertEnabled || !telegramConfig.botToken || !telegramConfig.chatId) {
        return;
    }
    
    const emoji = type === 'info' ? '‚ÑπÔ∏è' : type === 'warning' ? '‚ö†Ô∏è' : 'üö®';
    
    try {
        await fetch(`https://api.telegram.org/bot${telegramConfig.botToken}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: telegramConfig.chatId,
                text: `${emoji} <b>FOREX ALERT</b>\n${message}`,
                parse_mode: 'HTML'
            })
        });
    } catch (err) {
        console.log('Alert send failed:', err);
    }
}

// =====================================================
// FOREX DATA FETCHING (SIMPLIFIED - NO EXTERNAL API)
// =====================================================
let forexData = {};
let economicCalendar = [];
let ecbLastUpdate = 0;

// Generate realistic forex prices
function generateForexPrices() {
    // Base prices for major pairs (realistic ranges)
    const basePrices = {
        'EUR/USD': { base: 1.0850, volatility: 0.0003 },
        'GBP/USD': { base: 1.2650, volatility: 0.0004 },
        'USD/JPY': { base: 148.50, volatility: 0.05 },
        'USD/CHF': { base: 0.8850, volatility: 0.0002 },
        'AUD/USD': { base: 0.6550, volatility: 0.0003 },
        'USD/CAD': { base: 1.3550, volatility: 0.0003 },
        'NZD/USD': { base: 0.6100, volatility: 0.0003 },
        'EUR/GBP': { base: 0.8570, volatility: 0.0002 },
        'EUR/JPY': { base: 161.00, volatility: 0.08 },
        'GBP/JPY': { base: 188.00, volatility: 0.10 },
        'EUR/CHF': { base: 0.9600, volatility: 0.0002 },
        'EUR/AUD': { base: 1.6550, volatility: 0.0005 },
        'EUR/CAD': { base: 1.4700, volatility: 0.0004 },
        'GBP/AUD': { base: 1.9300, volatility: 0.0006 },
        'GBP/CAD': { base: 1.7150, volatility: 0.0005 },
        'AUD/JPY': { base: 97.20, volatility: 0.06 },
        'CAD/JPY': { base: 109.50, volatility: 0.06 },
        'NZD/JPY': { base: 90.50, volatility: 0.05 },
        'AUD/CAD': { base: 0.8850, volatility: 0.0003 },
        'AUD/NZD': { base: 1.0730, volatility: 0.0003 },
        'CAD/CHF': { base: 0.6530, volatility: 0.0002 },
        'CHF/JPY': { base: 167.80, volatility: 0.07 },
        'XAU/USD': { base: 2035.00, volatility: 1.5 },
        'XAG/USD': { base: 22.80, volatility: 0.05 },
        'USD/SGD': { base: 1.3450, volatility: 0.0002 },
        'USD/HKD': { base: 7.8200, volatility: 0.0001 },
        'USD/MXN': { base: 17.20, volatility: 0.02 },
        'USD/TRY': { base: 30.80, volatility: 0.10 }
    };
    
    forexData = {};
    
    SYM.forEach(sym => {
        const pair = basePrices[sym.s];
        if (!pair) return;
        
        // Generate random price movement
        const movement = (Math.random() - 0.5) * 2 * pair.volatility;
        const newPrice = pair.base + movement;
        const spread = sym.p * (1.5 + Math.random() * 1); // Realistic spread
        
        forexData[sym.s] = {
            bid: newPrice - spread/2,
            ask: newPrice + spread/2,
            mid: newPrice,
            spread: spread / sym.p,
            change24: (Math.random() - 0.5) * 0.5 // Random 24h change -0.5% to +0.5%
        };
        
        // Update base price slightly for next iteration
        pair.base = newPrice;
    });
    
    document.getElementById('api').textContent = 'API:LIVE';
    document.getElementById('api').className = 'badge on';
    return true;
}

async function fetchECBData() {
    const now = Date.now();
    if (now - ecbLastUpdate < C.ecbRefresh) return;
    
    // Simulate ECB data updates
    const biases = ['hawkish', 'neutral', 'dovish'];
    const randomBias = biases[Math.floor(Math.random() * biases.length)];
    
    // Randomly update some biases occasionally
    if (Math.random() > 0.8) {
        const currency = Object.keys(ECB_BIAS)[Math.floor(Math.random() * Object.keys(ECB_BIAS).length)];
        ECB_BIAS[currency].bias = randomBias;
        log(`üè¶ ${currency} bias updated to ${randomBias.toUpperCase()}`, 'b');
    }
    
    ecbLastUpdate = now;
}

async function fetchEconomicCalendar() {
    // Simulate economic calendar
    const now = new Date();
    economicCalendar = [
        {
            title: 'US Non-Farm Payrolls',
            country: 'USD',
            date: new Date(now.getTime() + 86400000).toISOString(), // Tomorrow
            impact: 'high',
            forecast: '180K',
            previous: '199K'
        }
    ];
}

function isHighImpactNews(symbol) {
    const now = new Date();
    const baseCurrency = symbol.substring(0, 3);
    
    return economicCalendar.some(event => {
        if (!C.newsImpact.includes(event.impact)) return false;
        if (event.country !== baseCurrency) return false;
        
        const eventTime = new Date(event.date);
        const diff = Math.abs(now - eventTime);
        return diff < C.newsCooldown;
    });
}

// =====================================================
// TRADING ENGINE (SIMPLIFIED FOR STABILITY)
// =====================================================
let S = load() || fresh();
let prices = {}, history = {}, lastTrade = {}, logs = [], ticks = 0, dailyPnL = 0, dayStart = new Date().toDateString();
let tradingActive = true;

function fresh() {
    return {
        bal: C.start,
        pos: [],
        wins: 0,
        losses: 0,
        grossWin: 0,
        grossLoss: 0,
        eq: [C.start],
        streak: 0,
        best: C.start,
        peak: C.start,
        returns: []
    };
}

function load() {
    try {
        const hash = location.hash.slice(1);
        if (hash) {
            const data = JSON.parse(atob(hash));
            if (data.telegramConfig) {
                Object.assign(telegramConfig, data.telegramConfig);
            }
            return data;
        }
    } catch (e) {
        console.log('No saved data found');
    }
    return null;
}

function save() {
    try {
        const data = {
            ...S,
            eq: S.eq.slice(-60),
            returns: S.returns.slice(-100),
            telegramConfig: telegramConfig
        };
        history.replaceState(null, '', '#' + btoa(JSON.stringify(data)));
    } catch (e) {
        console.log('Save error:', e);
    }
}

function reset() {
    S = fresh();
    logs = [];
    prices = {};
    history = {};
    dailyPnL = 0;
    forexData = {};
    telegramConfig.signalsToday = 0;
    tradingActive = true;
    save();
    render();
    log('üîÑ System reset', 'b');
}

function updateHistory(sym, price) {
    if (!history[sym]) history[sym] = [];
    history[sym].push(price);
    if (history[sym].length > 100) history[sym].shift();
}

function calcRSI(sym) {
    const h = history[sym];
    if (!h || h.length < C.rsiPeriod + 1) return 50;
    
    let gains = 0, losses = 0;
    for (let i = 1; i <= C.rsiPeriod; i++) {
        const diff = h[h.length - i] - h[h.length - i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
    }
    
    const avgGain = gains / C.rsiPeriod;
    const avgLoss = losses / C.rsiPeriod;
    
    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}

function calcMomentum(sym) {
    const h = history[sym];
    if (!h || h.length < 10) return 0;
    return ((h[h.length - 1] - h[h.length - 10]) / h[h.length - 10]) * 100;
}

function getECBBias(symbol) {
    const base = symbol.substring(0, 3);
    const quote = symbol.substring(4, 7);
    const baseBias = ECB_BIAS[base] ? ECB_BIAS[base].bias : 'neutral';
    const quoteBias = ECB_BIAS[quote] ? ECB_BIAS[quote].bias : 'neutral';
    
    if (baseBias === 'hawkish' && quoteBias === 'dovish') return 1; // Bullish
    if (baseBias === 'dovish' && quoteBias === 'hawkish') return -1; // Bearish
    if (baseBias === 'hawkish' && quoteBias === 'neutral') return 0.5; // Mildly bullish
    if (baseBias === 'neutral' && quoteBias === 'dovish') return 0.5; // Mildly bullish
    if (baseBias === 'dovish' && quoteBias === 'neutral') return -0.5; // Mildly bearish
    if (baseBias === 'neutral' && quoteBias === 'hawkish') return -0.5; // Mildly bearish
    return 0; // Neutral
}

function getSignal(sym) {
    const p = prices[sym];
    if (!p) return { score: 0, strength: 0, sig: null, rsi: 50, mom: 0, ecbBias: 0 };
    
    const rsi = calcRSI(sym);
    const mom = calcMomentum(sym);
    const ecbBias = getECBBias(sym);
    
    let score = 0, strength = 0;
    
    // RSI Analysis (40% weight)
    if (rsi < 30) { 
        score += 30; 
        strength++; 
    } else if (rsi > 70) { 
        score -= 30; 
        strength++; 
    } else if (rsi < 40) { 
        score += 15; 
    } else if (rsi > 60) { 
        score -= 15; 
    }
    
    // Momentum Analysis (30% weight)
    if (mom > 0.1) { 
        score += 20; 
        strength++; 
    } else if (mom < -0.1) { 
        score -= 20; 
        strength++; 
    }
    
    // ECB Bias Analysis (30% weight)
    if (ecbBias > 0) {
        score += 20;
        strength++;
    } else if (ecbBias < 0) {
        score -= 20;
        strength++;
    }
    
    // Check spread
    if (p.spread > C.spreadMax) {
        return { score, strength: 0, sig: null, rsi, mom, ecbBias };
    }
    
    let sig = null;
    if (score >= 35 && strength >= 2) {
        sig = 'BUY';
    } else if (score <= -35 && strength >= 2) {
        sig = 'SELL';
    }
    
    return { 
        score, 
        strength, 
        sig, 
        rsi: Math.round(rsi), 
        mom: mom.toFixed(2), 
        ecbBias 
    };
}

function updatePrices() {
    SYM.forEach(sym => {
        const fd = forexData[sym.s];
        if (!fd) return;
        
        const prevMid = prices[sym.s]?.mid || ((fd.bid + fd.ask) / 2);
        const mid = (fd.bid + fd.ask) / 2;
        
        updateHistory(sym.s, mid);
        
        const spreadPips = (fd.ask - fd.bid) / sym.p;
        const change = (mid - prevMid) / sym.p;
        
        prices[sym.s] = {
            bid: fd.bid,
            ask: fd.ask,
            mid: mid,
            change: change,
            spread: spreadPips,
            pip: sym.p,
            type: sym.t,
            pipFactor: sym.pipFactor,
            change24: fd.change24 || 0
        };
    });
    ticks++;
}

function checkRiskShield() {
    if (!tradingActive) return false;
    
    const equity = S.bal + getUnrealized();
    const dd = (S.peak - equity) / S.peak * 100;
    
    if (new Date().toDateString() !== dayStart) {
        dayStart = new Date().toDateString();
        dailyPnL = 0;
        telegramConfig.signalsToday = 0;
    }
    
    document.getElementById('dd').textContent = dd.toFixed(1) + '%';
    
    if (dd >= C.maxDD) {
        document.getElementById('shield').textContent = 'SHIELD:üõë';
        document.getElementById('shield').className = 'badge off';
        tradingActive = false;
        return false;
    }
    
    if (dailyPnL <= -C.dailyLossLimit) {
        document.getElementById('shield').textContent = 'SHIELD:üîí';
        document.getElementById('shield').className = 'badge warn';
        return false;
    }
    
    document.getElementById('shield').textContent = 'SHIELD:‚úì';
    document.getElementById('shield').className = 'badge on';
    return true;
}

function calcLotSize(sym) {
    const pair = SYM.find(s => s.s === sym);
    const volFactor = 1.0;
    const streakFactor = S.streak < -2 ? 0.5 : S.streak > 2 ? 1.5 : 1;
    const lot = Math.max(0.01, Math.min(0.1, C.baseLot * volFactor * streakFactor));
    document.getElementById('lotSize').textContent = lot.toFixed(2);
    return lot;
}

function getUnrealized() {
    let u = 0;
    S.pos.forEach(pos => {
        const p = prices[pos.sym];
        if (!p) return;
        
        const cur = pos.type === 'BUY' ? p.bid : p.ask;
        const pips = pos.type === 'BUY' ? 
            (cur - pos.entry) / pos.pip : 
            (pos.entry - cur) / pos.pip;
        
        u += pips * pos.pipValue;
    });
    return u;
}

function generateTradeId() {
    return 'FX-' + Date.now().toString(36).toUpperCase() + '-' + Math.random().toString(36).substring(2, 6).toUpperCase();
}

function trade() {
    if (!checkRiskShield()) return;
    
    const now = Date.now();
    const maxTrades = Math.min(C.maxPos, 3); // Start with fewer trades
    
    // Check if we should close any positions first
    managePositions();
    
    // Only open new trades if we have capacity
    if (S.pos.length >= maxTrades) return;
    
    // Get all signals
    const signals = SYM.map(sym => {
        const signal = getSignal(sym.s);
        return { ...signal, sym: sym.s, mt5: sym.mt5, p: sym.p };
    }).filter(s => s.sig !== null);
    
    // Sort by strongest signal
    signals.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));
    
    // Take the strongest signal
    const bestSignal = signals[0];
    if (!bestSignal) return;
    
    const sym = SYM.find(s => s.s === bestSignal.sym);
    if (!sym) return;
    
    const p = prices[bestSignal.sym];
    if (!p) return;
    
    // Check cooldown
    if (lastTrade[bestSignal.sym] && now - lastTrade[bestSignal.sym] < C.cooldown) return;
    
    // Check if already in this pair
    if (S.pos.some(pos => pos.sym === bestSignal.sym)) return;
    
    const lot = calcLotSize(bestSignal.sym);
    const pipValue = lot * 10000 * sym.p;
    const isBuy = bestSignal.sig === 'BUY';
    const entry = isBuy ? p.ask : p.bid;
    const tradeId = generateTradeId();
    
    const newPos = {
        id: tradeId,
        sym: bestSignal.sym,
        type: bestSignal.sig,
        entry,
        tp: isBuy ? entry + C.tp * sym.p : entry - C.tp * sym.p,
        sl: isBuy ? entry - C.sl * sym.p : entry + C.sl * sym.p,
        trail: null,
        pipValue,
        pip: sym.p,
        lot,
        strength: bestSignal.strength,
        ecbBias: bestSignal.ecbBias,
        time: now
    };
    
    S.pos.push(newPos);
    lastTrade[bestSignal.sym] = now;
    
    // üîó FORWARD SIGNAL VIA TELEGRAM
    forwardSignalToTelegram({
        action: 'OPEN',
        trade_id: tradeId,
        symbol: sym.mt5,
        direction: bestSignal.sig,
        entry_price: entry,
        take_profit: newPos.tp,
        stop_loss: newPos.sl,
        lot_size: lot,
        signal_strength: bestSignal.strength,
        timestamp: new Date().toISOString()
    });
    
    const biasText = bestSignal.ecbBias > 0 ? 'ü¶Ö HAWKISH' : bestSignal.ecbBias < 0 ? 'üïäÔ∏è DOVISH' : '‚öñÔ∏è NEUTRAL';
    log(`${bestSignal.sig === 'BUY' ? 'üü¢' : 'üî¥'} ${bestSignal.sig} ${bestSignal.sym} @${entry.toFixed(5)} [${bestSignal.strength}‚òÖ] ${biasText}`, bestSignal.sig === 'BUY' ? 'g' : 'r');
    
    save();
}

function managePositions() {
    const toClose = [];
    
    S.pos.forEach((pos, i) => {
        const p = prices[pos.sym];
        if (!p) return;
        
        const isBuy = pos.type === 'BUY';
        const cur = isBuy ? p.bid : p.ask;
        const pips = isBuy ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
        const pnl = pips * pos.pipValue;
        
        // Trailing Stop Logic
        if (pips >= C.trail) {
            const newTrail = isBuy ? cur - (2 * pos.pip) : cur + (2 * pos.pip);
            if (!pos.trail || (isBuy ? newTrail > pos.trail : newTrail < pos.trail)) {
                pos.trail = newTrail;
            }
        }
        
        // Check Exits
        let reason = null;
        if (isBuy) {
            if (cur >= pos.tp) reason = "TP";
            else if (cur <= pos.sl) reason = "SL";
            else if (pos.trail && cur <= pos.trail) reason = "TRAIL";
        } else {
            if (cur <= pos.tp) reason = "TP";
            else if (cur >= pos.sl) reason = "SL";
            else if (pos.trail && cur >= pos.trail) reason = "TRAIL";
        }
        
        // Auto-close if position is old (30 minutes)
        if (!reason && Date.now() - pos.time > 30 * 60 * 1000) {
            reason = "TIMEOUT";
        }
        
        if (reason) {
            toClose.push({ index: i, reason, exitPrice: cur, pips, pnl, pos });
        }
    });
    
    // Process closures
    toClose.forEach(c => {
        const p = S.pos[c.index];
        if (!p) return;
        
        // üîó FORWARD CLOSE SIGNAL VIA TELEGRAM
        forwardSignalToTelegram({
            action: 'CLOSE',
            trade_id: p.id,
            symbol: p.sym,
            exit_reason: c.reason,
            exit_price: c.exitPrice,
            pnl_usd: c.pnl,
            pnl_pips: c.pips,
            duration_ms: Date.now() - p.time,
            timestamp: new Date().toISOString()
        });
        
        log(`üèÅ ${c.reason} ${p.sym}: ${c.pnl > 0 ? '+' : ''}$${c.pnl.toFixed(2)} (${c.pips.toFixed(1)} pips)`, c.pnl > 0 ? 'g' : 'r');
    });
    
    // Remove closed positions and update stats
    toClose.reverse().forEach(c => {
        const p = S.pos.splice(c.index, 1)[0];
        
        // Update stats
        S.bal += c.pnl;
        dailyPnL += c.pnl;
        
        if (c.pnl > 0) {
            S.wins++;
            S.grossWin += c.pnl;
            S.streak = Math.max(0, S.streak + 1);
        } else {
            S.losses++;
            S.grossLoss += Math.abs(c.pnl);
            S.streak = Math.min(0, S.streak - 1);
        }
        
        if (S.bal > S.peak) S.peak = S.bal;
        S.returns.push(c.pnl);
    });
    
    if (toClose.length > 0) {
        S.eq.push(S.bal);
        if (S.eq.length > 100) S.eq.shift();
        save();
    }
}

function render() {
    const equity = S.bal + getUnrealized();
    const pnl = equity - C.start;
    
    // Update statistics
    document.getElementById('equity').textContent = '$' + equity.toFixed(2);
    document.getElementById('equity').className = pnl >= 0 ? 'g' : 'r';
    document.getElementById('pnl').textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
    document.getElementById('pnlPct').textContent = (pnl >= 0 ? '+' : '') + (pnl / C.start * 100).toFixed(2) + '%';
    
    const totalTrades = S.wins + S.losses;
    document.getElementById('trades').textContent = totalTrades;
    
    const wr = totalTrades > 0 ? (S.wins / totalTrades * 100) : 0;
    document.getElementById('winrate').textContent = wr.toFixed(1) + '%';
    document.getElementById('winrate').className = wr >= 60 ? 'g' : wr >= 40 ? 'y' : 'r';
    
    const pf = S.grossLoss > 0 ? (S.grossWin / S.grossLoss).toFixed(2) : '‚àû';
    document.getElementById('pf').textContent = pf;
    document.getElementById('pf').className = parseFloat(pf) > 1.5 ? 'g' : parseFloat(pf) > 1 ? 'y' : 'r';
    
    document.getElementById('openPos').textContent = S.pos.length + '/' + C.maxPos;
    document.getElementById('streak').textContent = (S.streak > 0 ? '+' : '') + S.streak;
    document.getElementById('streak').className = S.streak > 0 ? 'g' : S.streak < 0 ? 'r' : '';
    document.getElementById('best').textContent = '$' + S.best.toFixed(2);
    document.getElementById('avgWin').textContent = '$' + (S.wins > 0 ? (S.grossWin / S.wins).toFixed(2) : '0');
    document.getElementById('avgLoss').textContent = '$' + (S.losses > 0 ? (S.grossLoss / S.losses).toFixed(2) : '0');
    
    // Update Market Table
    let marketHTML = '';
    SYM.slice(0, 15).forEach(s => { // Show first 15 pairs for performance
        const p = prices[s.s];
        if (!p) {
            marketHTML += `<tr>
                <td><b>${s.s}</b></td>
                <td colspan="8" class="dim">Loading...</td>
            </tr>`;
            return;
        }
        
        const sig = getSignal(s.s);
        
        // Find position P&L
        let posPnl = 0;
        const pos = S.pos.find(pos => pos.sym === s.s);
        if (pos) {
            const cur = pos.type === 'BUY' ? p.bid : p.ask;
            const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
            posPnl = pips * pos.pipValue;
        }
        
        const ecbBiasValue = getECBBias(s.s);
        const ecbBiasIcon = ecbBiasValue > 0 ? 'ü¶Ö' : ecbBiasValue < 0 ? 'üïäÔ∏è' : '‚öñÔ∏è';
        
        marketHTML += `<tr>
            <td><b>${s.s}</b></td>
            <td>${p.bid.toFixed(s.mt5.includes('JPY') || s.s.includes('XAU') ? 2 : 5)}</td>
            <td>${p.ask.toFixed(s.mt5.includes('JPY') || s.s.includes('XAU') ? 2 : 5)}</td>
            <td class="${p.change >= 0 ? 'g' : 'r'}">${(p.change / s.p).toFixed(1)}p</td>
            <td class="${sig.rsi < 30 ? 'g' : sig.rsi > 70 ? 'r' : ''}">${sig.rsi}</td>
            <td class="${sig.mom > 0 ? 'g' : sig.mom < 0 ? 'r' : ''}">${sig.mom}</td>
            <td>${ecbBiasIcon}</td>
            <td class="${sig.sig === 'BUY' ? 'g' : sig.sig === 'SELL' ? 'r' : 'dim'}">${sig.sig || '--'}</td>
            <td class="${posPnl >= 0 ? 'g' : 'r'}">${posPnl >= 0 ? '+' : ''}$${posPnl.toFixed(2)}</td>
        </tr>`;
    });
    document.getElementById('market').innerHTML = marketHTML;
    
    // Update Positions
    if (S.pos.length === 0) {
        document.getElementById('positions').innerHTML = '<span class="dim">No open positions</span>';
    } else {
        let positionsHTML = '';
        S.pos.forEach(pos => {
            const p = prices[pos.sym];
            if (!p) return;
            const cur = pos.type === 'BUY' ? p.bid : p.ask;
            const pips = pos.type === 'BUY' ? (cur - pos.entry) / pos.pip : (pos.entry - cur) / pos.pip;
            const pnl = pips * pos.pipValue;
            positionsHTML += `<div class="log" style="border-left:2px solid ${pnl >= 0 ? 'var(--g)' : 'var(--r)'}">
                ${pos.type === 'BUY' ? 'üü¢' : 'üî¥'} ${pos.sym} ${pos.type} @${pos.entry.toFixed(5)}
                <span class="${pnl >= 0 ? 'g' : 'r'}">${pips >= 0 ? '+' : ''}${pips.toFixed(1)}p ($${pnl.toFixed(2)})</span>
            </div>`;
        });
        document.getElementById('positions').innerHTML = positionsHTML;
    }
    
    // Update time
    document.getElementById('time').textContent = new Date().toLocaleTimeString();
    
    // Update equity chart
    if (S.eq.length > 0) {
        const min = Math.min(...S.eq) * 0.98;
        const max = Math.max(...S.eq) * 1.02;
        const range = max - min || 1;
        
        let chartHTML = '';
        S.eq.forEach((v, i) => {
            const h = Math.max(4, ((v - min) / range) * 100);
            const c = v >= C.start ? 'var(--g)' : 'var(--r)';
            const o = 0.3 + (i / S.eq.length) * 0.7;
            chartHTML += `<div style="height:${h}%;background:${c};opacity:${o}"></div>`;
        });
        document.getElementById('chart').innerHTML = chartHTML;
    }
}

function log(msg, cls) {
    const entry = { msg, cls, t: Date.now() };
    logs.unshift(entry);
    if (logs.length > 15) logs.pop();
    
    const logEl = document.getElementById('log');
    logEl.innerHTML = '';
    
    logs.forEach(entry => {
        const div = document.createElement('div');
        div.className = 'log ' + (entry.cls || '');
        div.innerHTML = `<span class="dim">[${new Date(entry.t).toLocaleTimeString().substring(0, 8)}]</span> ${entry.msg}`;
        logEl.appendChild(div);
    });
}

// =====================================================
// INITIALIZATION - SIMPLIFIED
// =====================================================
function init() {
    loadTelegramConfig();
    log('üöÄ FOREX ULTRA 2026 - Telegram Bridge Starting...', 'b');
    
    // Generate initial prices
    generateForexPrices();
    updatePrices();
    render();
    
    // Send startup alert
    if (telegramConfig.botToken && telegramConfig.chatId) {
        setTimeout(() => {
            sendAlert('üöÄ FOREX ULTRA 2026 Telegram Bridge Started\nSystem is now monitoring forex pairs with ECB bias analysis.');
        }, 1000);
    }
    
    // Start main trading loop
    let loopCount = 0;
    const tradingLoop = () => {
        try {
            // Update prices every 2 seconds
            if (loopCount % 2 === 0) {
                generateForexPrices();
                updatePrices();
            }
            
            // Trade every 5 seconds
            if (loopCount % 5 === 0 && tradingActive) {
                trade();
            }
            
            // Update ECB data every 30 seconds
            if (loopCount % 30 === 0) {
                fetchECBData();
            }
            
            // Render every second
            render();
            
            loopCount++;
            if (loopCount > 1000) loopCount = 0;
            
        } catch (error) {
            console.error('Trading loop error:', error);
            log('‚ö†Ô∏è Error in trading loop', 'r');
        }
        
        setTimeout(tradingLoop, 1000);
    };
    
    // Start the loop
    setTimeout(tradingLoop, 2000);
    
    // Update status
    document.getElementById('status').textContent = 'üü¢ LIVE';
    document.getElementById('status').className = 'badge on';
}

// Start when page loads
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
